import {
  c,
  h,
  o
} from "./chunk-QBFRYOH7.js";
import "./chunk-4VMHPG2O.js";
import {
  require_is_graph
} from "./chunk-KWB6VWZC.js";
import "./chunk-5R2YFWNI.js";
import "./chunk-FCKPN5ZG.js";
import "./chunk-KNJF7WWH.js";
import {
  require_react
} from "./chunk-IYWZER4T.js";
import {
  __commonJS,
  __toESM
} from "./chunk-FDBJFBLO.js";

// node_modules/graphology-layout-noverlap/iterate.js
var require_iterate = __commonJS({
  "node_modules/graphology-layout-noverlap/iterate.js"(exports, module) {
    var NODE_X = 0;
    var NODE_Y = 1;
    var NODE_SIZE = 2;
    var PPN = 3;
    function hashPair(a2, b) {
      return a2 + "ยง" + b;
    }
    function jitter() {
      return 0.01 * (0.5 - Math.random());
    }
    module.exports = function iterate(options, NodeMatrix) {
      var margin = options.margin;
      var ratio = options.ratio;
      var expansion = options.expansion;
      var gridSize = options.gridSize;
      var speed = options.speed;
      var i, j, x, y, l2, size;
      var converged = true;
      var length = NodeMatrix.length;
      var order = length / PPN | 0;
      var deltaX = new Float32Array(order);
      var deltaY = new Float32Array(order);
      var xMin = Infinity;
      var yMin = Infinity;
      var xMax = -Infinity;
      var yMax = -Infinity;
      for (i = 0; i < length; i += PPN) {
        x = NodeMatrix[i + NODE_X];
        y = NodeMatrix[i + NODE_Y];
        size = NodeMatrix[i + NODE_SIZE] * ratio + margin;
        xMin = Math.min(xMin, x - size);
        xMax = Math.max(xMax, x + size);
        yMin = Math.min(yMin, y - size);
        yMax = Math.max(yMax, y + size);
      }
      var width = xMax - xMin;
      var height = yMax - yMin;
      var xCenter = (xMin + xMax) / 2;
      var yCenter = (yMin + yMax) / 2;
      xMin = xCenter - expansion * width / 2;
      xMax = xCenter + expansion * width / 2;
      yMin = yCenter - expansion * height / 2;
      yMax = yCenter + expansion * height / 2;
      var grid = new Array(gridSize * gridSize), gridLength = grid.length, c2;
      for (c2 = 0; c2 < gridLength; c2++) grid[c2] = [];
      var nxMin, nxMax, nyMin, nyMax;
      var xMinBox, xMaxBox, yMinBox, yMaxBox;
      var col, row;
      for (i = 0; i < length; i += PPN) {
        x = NodeMatrix[i + NODE_X];
        y = NodeMatrix[i + NODE_Y];
        size = NodeMatrix[i + NODE_SIZE] * ratio + margin;
        nxMin = x - size;
        nxMax = x + size;
        nyMin = y - size;
        nyMax = y + size;
        xMinBox = Math.floor(gridSize * (nxMin - xMin) / (xMax - xMin));
        xMaxBox = Math.floor(gridSize * (nxMax - xMin) / (xMax - xMin));
        yMinBox = Math.floor(gridSize * (nyMin - yMin) / (yMax - yMin));
        yMaxBox = Math.floor(gridSize * (nyMax - yMin) / (yMax - yMin));
        for (col = xMinBox; col <= xMaxBox; col++) {
          for (row = yMinBox; row <= yMaxBox; row++) {
            grid[col * gridSize + row].push(i);
          }
        }
      }
      var cell;
      var collisions = /* @__PURE__ */ new Set();
      var n1, n2, x1, x2, y1, y2, s1, s2, h2;
      var xDist, yDist, dist, collision;
      for (c2 = 0; c2 < gridLength; c2++) {
        cell = grid[c2];
        for (i = 0, l2 = cell.length; i < l2; i++) {
          n1 = cell[i];
          x1 = NodeMatrix[n1 + NODE_X];
          y1 = NodeMatrix[n1 + NODE_Y];
          s1 = NodeMatrix[n1 + NODE_SIZE];
          for (j = i + 1; j < l2; j++) {
            n2 = cell[j];
            h2 = hashPair(n1, n2);
            if (gridLength > 1 && collisions.has(h2)) continue;
            if (gridLength > 1) collisions.add(h2);
            x2 = NodeMatrix[n2 + NODE_X];
            y2 = NodeMatrix[n2 + NODE_Y];
            s2 = NodeMatrix[n2 + NODE_SIZE];
            xDist = x2 - x1;
            yDist = y2 - y1;
            dist = Math.sqrt(xDist * xDist + yDist * yDist);
            collision = dist < s1 * ratio + margin + (s2 * ratio + margin);
            if (collision) {
              converged = false;
              n2 = n2 / PPN | 0;
              if (dist > 0) {
                deltaX[n2] += xDist / dist * (1 + s1);
                deltaY[n2] += yDist / dist * (1 + s1);
              } else {
                deltaX[n2] += width * jitter();
                deltaY[n2] += height * jitter();
              }
            }
          }
        }
      }
      for (i = 0, j = 0; i < length; i += PPN, j++) {
        NodeMatrix[i + NODE_X] += deltaX[j] * 0.1 * speed;
        NodeMatrix[i + NODE_Y] += deltaY[j] * 0.1 * speed;
      }
      return { converged };
    };
  }
});

// node_modules/graphology-layout-noverlap/helpers.js
var require_helpers = __commonJS({
  "node_modules/graphology-layout-noverlap/helpers.js"(exports) {
    var PPN = 3;
    exports.validateSettings = function(settings) {
      if ("gridSize" in settings && typeof settings.gridSize !== "number" || settings.gridSize <= 0)
        return { message: "the `gridSize` setting should be a positive number." };
      if ("margin" in settings && typeof settings.margin !== "number" || settings.margin < 0)
        return {
          message: "the `margin` setting should be 0 or a positive number."
        };
      if ("expansion" in settings && typeof settings.expansion !== "number" || settings.expansion <= 0)
        return { message: "the `expansion` setting should be a positive number." };
      if ("ratio" in settings && typeof settings.ratio !== "number" || settings.ratio <= 0)
        return { message: "the `ratio` setting should be a positive number." };
      if ("speed" in settings && typeof settings.speed !== "number" || settings.speed <= 0)
        return { message: "the `speed` setting should be a positive number." };
      return null;
    };
    exports.graphToByteArray = function(graph, reducer) {
      var order = graph.order;
      var matrix = new Float32Array(order * PPN);
      var j = 0;
      graph.forEachNode(function(node, attr) {
        if (typeof reducer === "function") attr = reducer(node, attr);
        matrix[j] = attr.x;
        matrix[j + 1] = attr.y;
        matrix[j + 2] = attr.size || 1;
        j += PPN;
      });
      return matrix;
    };
    exports.assignLayoutChanges = function(graph, NodeMatrix, reducer) {
      var i = 0;
      graph.forEachNode(function(node) {
        var pos = {
          x: NodeMatrix[i],
          y: NodeMatrix[i + 1]
        };
        if (typeof reducer === "function") pos = reducer(node, pos);
        graph.mergeNodeAttributes(node, pos);
        i += PPN;
      });
    };
    exports.collectLayoutChanges = function(graph, NodeMatrix, reducer) {
      var positions = {};
      var i = 0;
      graph.forEachNode(function(node) {
        var pos = {
          x: NodeMatrix[i],
          y: NodeMatrix[i + 1]
        };
        if (typeof reducer === "function") pos = reducer(node, pos);
        positions[node] = pos;
        i += PPN;
      });
      return positions;
    };
    exports.createWorker = function createWorker(fn) {
      var xURL = window.URL || window.webkitURL;
      var code = fn.toString();
      var objectUrl = xURL.createObjectURL(
        new Blob(["(" + code + ").call(this);"], { type: "text/javascript" })
      );
      var worker = new Worker(objectUrl);
      xURL.revokeObjectURL(objectUrl);
      return worker;
    };
  }
});

// node_modules/graphology-layout-noverlap/defaults.js
var require_defaults = __commonJS({
  "node_modules/graphology-layout-noverlap/defaults.js"(exports, module) {
    module.exports = {
      gridSize: 20,
      margin: 5,
      expansion: 1.1,
      ratio: 1,
      speed: 3
    };
  }
});

// node_modules/graphology-layout-noverlap/index.js
var require_graphology_layout_noverlap = __commonJS({
  "node_modules/graphology-layout-noverlap/index.js"(exports, module) {
    var isGraph = require_is_graph();
    var iterate = require_iterate();
    var helpers = require_helpers();
    var DEFAULT_SETTINGS = require_defaults();
    var DEFAULT_MAX_ITERATIONS = 500;
    function abstractSynchronousLayout(assign, graph, params) {
      if (!isGraph(graph))
        throw new Error(
          "graphology-layout-noverlap: the given graph is not a valid graphology instance."
        );
      if (typeof params === "number") params = { maxIterations: params };
      else params = params || {};
      var maxIterations = params.maxIterations || DEFAULT_MAX_ITERATIONS;
      if (typeof maxIterations !== "number" || maxIterations <= 0)
        throw new Error(
          "graphology-layout-force: you should provide a positive number of maximum iterations."
        );
      var settings = Object.assign({}, DEFAULT_SETTINGS, params.settings), validationError = helpers.validateSettings(settings);
      if (validationError)
        throw new Error("graphology-layout-noverlap: " + validationError.message);
      var matrix = helpers.graphToByteArray(graph, params.inputReducer), converged = false, i;
      for (i = 0; i < maxIterations && !converged; i++)
        converged = iterate(settings, matrix).converged;
      if (assign) {
        helpers.assignLayoutChanges(graph, matrix, params.outputReducer);
        return;
      }
      return helpers.collectLayoutChanges(graph, matrix, params.outputReducer);
    }
    var synchronousLayout = abstractSynchronousLayout.bind(null, false);
    synchronousLayout.assign = abstractSynchronousLayout.bind(null, true);
    module.exports = synchronousLayout;
  }
});

// node_modules/graphology-layout-noverlap/webworker.js
var require_webworker = __commonJS({
  "node_modules/graphology-layout-noverlap/webworker.js"(exports, module) {
    module.exports = function worker() {
      var NODES;
      var moduleShim = {};
      (function() {
        var NODE_X = 0, NODE_Y = 1, NODE_SIZE = 2;
        var PPN = 3;
        function hashPair(a2, b) {
          return a2 + "ยง" + b;
        }
        function jitter() {
          return 0.01 * (0.5 - Math.random());
        }
        moduleShim.exports = function iterate2(options, NodeMatrix) {
          var margin = options.margin;
          var ratio = options.ratio;
          var expansion = options.expansion;
          var gridSize = options.gridSize;
          var speed = options.speed;
          var i, j, x, y, l2, size;
          var converged = true;
          var length = NodeMatrix.length;
          var order = length / PPN | 0;
          var deltaX = new Float32Array(order);
          var deltaY = new Float32Array(order);
          var xMin = Infinity;
          var yMin = Infinity;
          var xMax = -Infinity;
          var yMax = -Infinity;
          for (i = 0; i < length; i += PPN) {
            x = NodeMatrix[i + NODE_X];
            y = NodeMatrix[i + NODE_Y];
            size = NodeMatrix[i + NODE_SIZE] * ratio + margin;
            xMin = Math.min(xMin, x - size);
            xMax = Math.max(xMax, x + size);
            yMin = Math.min(yMin, y - size);
            yMax = Math.max(yMax, y + size);
          }
          var width = xMax - xMin;
          var height = yMax - yMin;
          var xCenter = (xMin + xMax) / 2;
          var yCenter = (yMin + yMax) / 2;
          xMin = xCenter - expansion * width / 2;
          xMax = xCenter + expansion * width / 2;
          yMin = yCenter - expansion * height / 2;
          yMax = yCenter + expansion * height / 2;
          var grid = new Array(gridSize * gridSize), gridLength = grid.length, c2;
          for (c2 = 0; c2 < gridLength; c2++) grid[c2] = [];
          var nxMin, nxMax, nyMin, nyMax;
          var xMinBox, xMaxBox, yMinBox, yMaxBox;
          var col, row;
          for (i = 0; i < length; i += PPN) {
            x = NodeMatrix[i + NODE_X];
            y = NodeMatrix[i + NODE_Y];
            size = NodeMatrix[i + NODE_SIZE] * ratio + margin;
            nxMin = x - size;
            nxMax = x + size;
            nyMin = y - size;
            nyMax = y + size;
            xMinBox = Math.floor(gridSize * (nxMin - xMin) / (xMax - xMin));
            xMaxBox = Math.floor(gridSize * (nxMax - xMin) / (xMax - xMin));
            yMinBox = Math.floor(gridSize * (nyMin - yMin) / (yMax - yMin));
            yMaxBox = Math.floor(gridSize * (nyMax - yMin) / (yMax - yMin));
            for (col = xMinBox; col <= xMaxBox; col++) {
              for (row = yMinBox; row <= yMaxBox; row++) {
                grid[col * gridSize + row].push(i);
              }
            }
          }
          var cell;
          var collisions = /* @__PURE__ */ new Set();
          var n1, n2, x1, x2, y1, y2, s1, s2, h2;
          var xDist, yDist, dist, collision;
          for (c2 = 0; c2 < gridLength; c2++) {
            cell = grid[c2];
            for (i = 0, l2 = cell.length; i < l2; i++) {
              n1 = cell[i];
              x1 = NodeMatrix[n1 + NODE_X];
              y1 = NodeMatrix[n1 + NODE_Y];
              s1 = NodeMatrix[n1 + NODE_SIZE];
              for (j = i + 1; j < l2; j++) {
                n2 = cell[j];
                h2 = hashPair(n1, n2);
                if (gridLength > 1 && collisions.has(h2)) continue;
                if (gridLength > 1) collisions.add(h2);
                x2 = NodeMatrix[n2 + NODE_X];
                y2 = NodeMatrix[n2 + NODE_Y];
                s2 = NodeMatrix[n2 + NODE_SIZE];
                xDist = x2 - x1;
                yDist = y2 - y1;
                dist = Math.sqrt(xDist * xDist + yDist * yDist);
                collision = dist < s1 * ratio + margin + (s2 * ratio + margin);
                if (collision) {
                  converged = false;
                  n2 = n2 / PPN | 0;
                  if (dist > 0) {
                    deltaX[n2] += xDist / dist * (1 + s1);
                    deltaY[n2] += yDist / dist * (1 + s1);
                  } else {
                    deltaX[n2] += width * jitter();
                    deltaY[n2] += height * jitter();
                  }
                }
              }
            }
          }
          for (i = 0, j = 0; i < length; i += PPN, j++) {
            NodeMatrix[i + NODE_X] += deltaX[j] * 0.1 * speed;
            NodeMatrix[i + NODE_Y] += deltaY[j] * 0.1 * speed;
          }
          return { converged };
        };
      })();
      var iterate = moduleShim.exports;
      self.addEventListener("message", function(event) {
        var data = event.data;
        NODES = new Float32Array(data.nodes);
        var result = iterate(data.settings, NODES);
        self.postMessage(
          {
            result,
            nodes: NODES.buffer
          },
          [NODES.buffer]
        );
      });
    };
  }
});

// node_modules/graphology-layout-noverlap/worker.js
var require_worker = __commonJS({
  "node_modules/graphology-layout-noverlap/worker.js"(exports, module) {
    var workerFunction = require_webworker();
    var isGraph = require_is_graph();
    var helpers = require_helpers();
    var DEFAULT_SETTINGS = require_defaults();
    function NoverlapLayoutSupervisor(graph, params) {
      params = params || {};
      if (!isGraph(graph))
        throw new Error(
          "graphology-layout-noverlap/worker: the given graph is not a valid graphology instance."
        );
      var settings = Object.assign({}, DEFAULT_SETTINGS, params.settings), validationError = helpers.validateSettings(settings);
      if (validationError)
        throw new Error(
          "graphology-layout-noverlap/worker: " + validationError.message
        );
      this.worker = null;
      this.graph = graph;
      this.settings = settings;
      this.matrices = null;
      this.running = false;
      this.killed = false;
      this.inputReducer = params.inputReducer;
      this.outputReducer = params.outputReducer;
      this.callbacks = {
        onConverged: typeof params.onConverged === "function" ? params.onConverged : null
      };
      this.handleMessage = this.handleMessage.bind(this);
      var alreadyRespawning = false;
      var self2 = this;
      this.handleAddition = function() {
        if (alreadyRespawning) return;
        alreadyRespawning = true;
        self2.spawnWorker();
        setTimeout(function() {
          alreadyRespawning = false;
        }, 0);
      };
      graph.on("nodeAdded", this.handleAddition);
      graph.on("edgeAdded", this.handleAddition);
      this.spawnWorker();
    }
    NoverlapLayoutSupervisor.prototype.isRunning = function() {
      return this.running;
    };
    NoverlapLayoutSupervisor.prototype.spawnWorker = function() {
      if (this.worker) this.worker.terminate();
      this.worker = helpers.createWorker(workerFunction);
      this.worker.addEventListener("message", this.handleMessage);
      if (this.running) {
        this.running = false;
        this.start();
      }
    };
    NoverlapLayoutSupervisor.prototype.handleMessage = function(event) {
      if (!this.running) return;
      var matrix = new Float32Array(event.data.nodes);
      helpers.assignLayoutChanges(this.graph, matrix, this.outputReducer);
      this.matrices.nodes = matrix;
      if (event.data.result.converged) {
        if (this.callbacks.onConverged) this.callbacks.onConverged();
        this.stop();
        return;
      }
      this.askForIterations();
    };
    NoverlapLayoutSupervisor.prototype.askForIterations = function() {
      var matrices = this.matrices;
      var payload = {
        settings: this.settings,
        nodes: matrices.nodes.buffer
      };
      var buffers = [matrices.nodes.buffer];
      this.worker.postMessage(payload, buffers);
      return this;
    };
    NoverlapLayoutSupervisor.prototype.start = function() {
      if (this.killed)
        throw new Error(
          "graphology-layout-noverlap/worker.start: layout was killed."
        );
      if (this.running) return this;
      this.matrices = {
        nodes: helpers.graphToByteArray(this.graph, this.inputReducer)
      };
      this.running = true;
      this.askForIterations();
      return this;
    };
    NoverlapLayoutSupervisor.prototype.stop = function() {
      this.running = false;
      return this;
    };
    NoverlapLayoutSupervisor.prototype.kill = function() {
      if (this.killed) return this;
      this.running = false;
      this.killed = true;
      this.matrices = null;
      this.worker.terminate();
      this.graph.removeListener("nodeAdded", this.handleAddition);
      this.graph.removeListener("edgeAdded", this.handleAddition);
    };
    module.exports = NoverlapLayoutSupervisor;
  }
});

// node_modules/@react-sigma/layout-noverlap/lib/react-sigma_layout-noverlap.esm.min.js
var import_graphology_layout_noverlap = __toESM(require_graphology_layout_noverlap());
var import_worker = __toESM(require_worker());
var import_react = __toESM(require_react());
function n(r = {}) {
  return o(import_graphology_layout_noverlap.default, r);
}
function s(o2 = {}) {
  return c(import_worker.default, o2);
}
var u = ({ id: o2, className: r, style: e2, settings: a2 = {}, autoRunFor: n2, children: u2, labels: c2 }) => {
  const i = { id: o2, className: r, style: e2, autoRunFor: n2, labels: c2, layout: s(a2) };
  return import_react.default.createElement(h, Object.assign({}, i), u2);
};
export {
  u as LayoutNoverlapControl,
  n as useLayoutNoverlap,
  s as useWorkerLayoutNoverlap
};
//# sourceMappingURL=@react-sigma_layout-noverlap.js.map
