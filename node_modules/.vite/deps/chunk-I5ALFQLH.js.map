{
  "version": 3,
  "sources": ["../../sigma/rendering/dist/sigma-rendering.esm.js"],
  "sourcesContent": ["import { f as NodeProgram, D as DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS, _ as _objectSpread2, F as FRAGMENT_SHADER_SOURCE$3, g as EdgeProgram, h as createEdgeCompoundProgram, i as createEdgeArrowHeadProgram } from '../../dist/index-236c62ad.esm.js';\nexport { k as AbstractEdgeProgram, A as AbstractNodeProgram, l as AbstractProgram, D as DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS, p as DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS, m as EdgeArrowHeadProgram, E as EdgeArrowProgram, n as EdgeClampedProgram, g as EdgeProgram, e as EdgeRectangleProgram, N as NodeCircleProgram, f as NodeProgram, P as Program, i as createEdgeArrowHeadProgram, q as createEdgeArrowProgram, o as createEdgeClampedProgram, h as createEdgeCompoundProgram, j as createNodeCompoundProgram, c as drawDiscNodeHover, b as drawDiscNodeLabel, d as drawStraightEdgeLabel, r as getAttributeItemsCount, s as getAttributesItemsCount, w as killProgram, u as loadFragmentShader, v as loadProgram, t as loadVertexShader, x as numberToGLSLFloat } from '../../dist/index-236c62ad.esm.js';\nimport { _ as _inherits, a as _createClass, b as _classCallCheck, c as _callSuper } from '../../dist/inherits-d1a1e29b.esm.js';\nimport { f as floatColor } from '../../dist/colors-beb06eb2.esm.js';\n\n// language=GLSL\nvar SHADER_SOURCE$6 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float radius = 0.5;\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\\n  float dist = radius - length(m);\\n\\n  // No antialiasing for picking mode:\\n  #ifdef PICKING_MODE\\n  if (dist > v_border)\\n    gl_FragColor = v_color;\\n  else\\n    gl_FragColor = transparent;\\n\\n  #else\\n  float t = 0.0;\\n  if (dist > v_border)\\n    t = 1.0;\\n  else if (dist > 0.0)\\n    t = dist / v_border;\\n\\n  gl_FragColor = mix(transparent, v_color, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$6;\n\n// language=GLSL\nvar SHADER_SOURCE$5 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\nattribute float a_size;\\n\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  // Multiply the point size twice:\\n  //  - x SCALING_RATIO to correct the canvas scaling\\n  //  - x 2 to correct the formulae\\n  gl_PointSize = a_size / u_sizeRatio * u_pixelRatio * 2.0;\\n\\n  v_border = (0.5 / a_size) * u_sizeRatio;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$3 = SHADER_SOURCE$5;\n\nvar _WebGLRenderingContex$3 = WebGLRenderingContext,\n  UNSIGNED_BYTE$3 = _WebGLRenderingContex$3.UNSIGNED_BYTE,\n  FLOAT$3 = _WebGLRenderingContex$3.FLOAT;\nvar UNIFORMS$3 = [\"u_sizeRatio\", \"u_pixelRatio\", \"u_matrix\"];\nvar NodePointProgram = /*#__PURE__*/function (_NodeProgram) {\n  function NodePointProgram() {\n    _classCallCheck(this, NodePointProgram);\n    return _callSuper(this, NodePointProgram, arguments);\n  }\n  _inherits(NodePointProgram, _NodeProgram);\n  return _createClass(NodePointProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 1,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$3,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,\n        METHOD: WebGLRenderingContext.POINTS,\n        UNIFORMS: UNIFORMS$3,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$3\n        }, {\n          name: \"a_size\",\n          size: 1,\n          type: FLOAT$3\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(nodeIndex, startIndex, data) {\n      var array = this.array;\n      array[startIndex++] = data.x;\n      array[startIndex++] = data.y;\n      array[startIndex++] = data.size;\n      array[startIndex++] = floatColor(data.color);\n      array[startIndex++] = nodeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(_ref, _ref2) {\n      var sizeRatio = _ref.sizeRatio,\n        pixelRatio = _ref.pixelRatio,\n        matrix = _ref.matrix;\n      var gl = _ref2.gl,\n        uniformLocations = _ref2.uniformLocations;\n      var u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_pixelRatio = uniformLocations.u_pixelRatio,\n        u_matrix = uniformLocations.u_matrix;\n      gl.uniform1f(u_pixelRatio, pixelRatio);\n      gl.uniform1f(u_sizeRatio, sizeRatio);\n      gl.uniformMatrix3fv(u_matrix, false, matrix);\n    }\n  }]);\n}(NodeProgram);\n\n// language=GLSL\nvar SHADER_SOURCE$4 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\nattribute float a_sourceRadius;\\nattribute float a_targetRadius;\\nattribute float a_sourceRadiusCoef;\\nattribute float a_targetRadiusCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_zoomRatio;\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform float u_correctionRatio;\\nuniform float u_minEdgeThickness;\\nuniform float u_lengthToThicknessRatio;\\nuniform float u_feather;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\nvarying float v_feather;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float minThickness = u_minEdgeThickness;\\n\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl. Please read it to\\n  // get better comments on what's happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here, we move the point to leave space for the arrow heads:\\n  // Source arrow head\\n  float sourceRadius = a_sourceRadius * a_sourceRadiusCoef;\\n  float sourceDirection = sign(sourceRadius);\\n  float webGLSourceRadius = sourceDirection * sourceRadius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLSourceArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\\n  vec2 sourceCompensationVector =\\n    vec2(-sourceDirection * unitNormal.y, sourceDirection * unitNormal.x)\\n    * (webGLSourceRadius + webGLSourceArrowHeadLength);\\n    \\n  // Target arrow head\\n  float targetRadius = a_targetRadius * a_targetRadiusCoef;\\n  float targetDirection = sign(targetRadius);\\n  float webGLTargetRadius = targetDirection * targetRadius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLTargetArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\\n  vec2 targetCompensationVector =\\n  vec2(-targetDirection * unitNormal.y, targetDirection * unitNormal.x)\\n    * (webGLTargetRadius + webGLTargetArrowHeadLength);\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + sourceCompensationVector + targetCompensationVector, 1)).xy, 0, 1);\\n\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$4;\n\nvar _WebGLRenderingContex$2 = WebGLRenderingContext,\n  UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE,\n  FLOAT$2 = _WebGLRenderingContex$2.FLOAT;\nvar UNIFORMS$2 = [\"u_matrix\", \"u_zoomRatio\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_pixelRatio\", \"u_feather\", \"u_minEdgeThickness\", \"u_lengthToThicknessRatio\"];\nvar DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS = {\n  lengthToThicknessRatio: DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS.lengthToThicknessRatio\n};\nfunction createEdgeDoubleClampedProgram(inputOptions) {\n  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS), inputOptions || {});\n  return /*#__PURE__*/function (_EdgeProgram) {\n    function EdgeDoubleClampedProgram() {\n      _classCallCheck(this, EdgeDoubleClampedProgram);\n      return _callSuper(this, EdgeDoubleClampedProgram, arguments);\n    }\n    _inherits(EdgeDoubleClampedProgram, _EdgeProgram);\n    return _createClass(EdgeDoubleClampedProgram, [{\n      key: \"getDefinition\",\n      value: function getDefinition() {\n        return {\n          VERTICES: 6,\n          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,\n          FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$3,\n          METHOD: WebGLRenderingContext.TRIANGLES,\n          UNIFORMS: UNIFORMS$2,\n          ATTRIBUTES: [{\n            name: \"a_positionStart\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_positionEnd\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_normal\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_color\",\n            size: 4,\n            type: UNSIGNED_BYTE$2,\n            normalized: true\n          }, {\n            name: \"a_id\",\n            size: 4,\n            type: UNSIGNED_BYTE$2,\n            normalized: true\n          }, {\n            name: \"a_sourceRadius\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_targetRadius\",\n            size: 1,\n            type: FLOAT$2\n          }],\n          CONSTANT_ATTRIBUTES: [\n          // If 0, then position will be a_positionStart\n          // If 1, then position will be a_positionEnd\n          {\n            name: \"a_positionCoef\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_normalCoef\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_sourceRadiusCoef\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_targetRadiusCoef\",\n            size: 1,\n            type: FLOAT$2\n          }],\n          CONSTANT_DATA: [[0, 1, -1, 0], [0, -1, 1, 0], [1, 1, 0, 1], [1, 1, 0, 1], [0, -1, 1, 0], [1, -1, 0, -1]]\n        };\n      }\n    }, {\n      key: \"processVisibleItem\",\n      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n        var thickness = data.size || 1;\n        var x1 = sourceData.x;\n        var y1 = sourceData.y;\n        var x2 = targetData.x;\n        var y2 = targetData.y;\n        var color = floatColor(data.color);\n\n        // Computing normals\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        var sourceRadius = sourceData.size || 1;\n        var targetRadius = targetData.size || 1;\n        var len = dx * dx + dy * dy;\n        var n1 = 0;\n        var n2 = 0;\n        if (len) {\n          len = 1 / Math.sqrt(len);\n          n1 = -dy * len * thickness;\n          n2 = dx * len * thickness;\n        }\n        var array = this.array;\n        array[startIndex++] = x1;\n        array[startIndex++] = y1;\n        array[startIndex++] = x2;\n        array[startIndex++] = y2;\n        array[startIndex++] = n1;\n        array[startIndex++] = n2;\n        array[startIndex++] = color;\n        array[startIndex++] = edgeIndex;\n        array[startIndex++] = sourceRadius;\n        array[startIndex++] = targetRadius;\n      }\n    }, {\n      key: \"setUniforms\",\n      value: function setUniforms(params, _ref) {\n        var gl = _ref.gl,\n          uniformLocations = _ref.uniformLocations;\n        var u_matrix = uniformLocations.u_matrix,\n          u_zoomRatio = uniformLocations.u_zoomRatio,\n          u_feather = uniformLocations.u_feather,\n          u_pixelRatio = uniformLocations.u_pixelRatio,\n          u_correctionRatio = uniformLocations.u_correctionRatio,\n          u_sizeRatio = uniformLocations.u_sizeRatio,\n          u_minEdgeThickness = uniformLocations.u_minEdgeThickness,\n          u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio;\n        gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n        gl.uniform1f(u_zoomRatio, params.zoomRatio);\n        gl.uniform1f(u_sizeRatio, params.sizeRatio);\n        gl.uniform1f(u_correctionRatio, params.correctionRatio);\n        gl.uniform1f(u_pixelRatio, params.pixelRatio);\n        gl.uniform1f(u_feather, params.antiAliasingFeather);\n        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n        gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);\n      }\n    }]);\n  }(EdgeProgram);\n}\nvar EdgeDoubleClampedProgram = createEdgeDoubleClampedProgram();\nvar EdgeDoubleClampedProgram$1 = EdgeDoubleClampedProgram;\n\nfunction createEdgeDoubleArrowProgram(inputOptions) {\n  return createEdgeCompoundProgram([createEdgeDoubleClampedProgram(inputOptions), createEdgeArrowHeadProgram(inputOptions), createEdgeArrowHeadProgram(_objectSpread2(_objectSpread2({}, inputOptions), {}, {\n    extremity: \"source\"\n  }))]);\n}\nvar EdgeDoubleArrowProgram = createEdgeDoubleArrowProgram();\nvar EdgeDoubleArrowProgram$1 = EdgeDoubleArrowProgram;\n\n// language=GLSL\nvar SHADER_SOURCE$3 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$3;\n\n// language=GLSL\nvar SHADER_SOURCE$2 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\n\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  // Scale from [[-1 1] [-1 1]] to the container:\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$2;\n\nvar _WebGLRenderingContex$1 = WebGLRenderingContext,\n  UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE,\n  FLOAT$1 = _WebGLRenderingContex$1.FLOAT;\nvar UNIFORMS$1 = [\"u_matrix\"];\nvar EdgeLineProgram = /*#__PURE__*/function (_EdgeProgram) {\n  function EdgeLineProgram() {\n    _classCallCheck(this, EdgeLineProgram);\n    return _callSuper(this, EdgeLineProgram, arguments);\n  }\n  _inherits(EdgeLineProgram, _EdgeProgram);\n  return _createClass(EdgeLineProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 2,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,\n        METHOD: WebGLRenderingContext.LINES,\n        UNIFORMS: UNIFORMS$1,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var array = this.array;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // First point\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n\n      // Second point\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    }\n  }]);\n}(EdgeProgram);\n\n// language=GLSL\nvar SHADER_SOURCE$1 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$1;\n\n// language=GLSL\nvar SHADER_SOURCE = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  // The only different here with edge.vert.glsl is that we need to handle null\\n  // input normal vector. Apart from that, you can read edge.vert.glsl more info\\n  // on how it works:\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n  if (normalLength <= 0.0) unitNormal = normal;\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE = SHADER_SOURCE;\n\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nvar UNIFORMS = [\"u_matrix\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_minEdgeThickness\"];\nvar EdgeTriangleProgram = /*#__PURE__*/function (_EdgeProgram) {\n  function EdgeTriangleProgram() {\n    _classCallCheck(this, EdgeTriangleProgram);\n    return _callSuper(this, EdgeTriangleProgram, arguments);\n  }\n  _inherits(EdgeTriangleProgram, _EdgeProgram);\n  return _createClass(EdgeTriangleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS,\n        ATTRIBUTES: [{\n          name: \"a_positionStart\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_positionEnd\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 1, then position will be a_positionEnd\n        {\n          name: \"a_positionCoef\",\n          size: 1,\n          type: FLOAT\n        }, {\n          name: \"a_normalCoef\",\n          size: 1,\n          type: FLOAT\n        }],\n        CONSTANT_DATA: [[0, 1], [0, -1], [1, 0]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n\n      // First point\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix,\n        u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_minEdgeThickness = uniformLocations.u_minEdgeThickness;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n    }\n  }]);\n}(EdgeProgram);\n\nexport { DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS, EdgeDoubleArrowProgram$1 as EdgeDoubleArrowProgram, EdgeDoubleClampedProgram$1 as EdgeDoubleClampedProgram, EdgeLineProgram, EdgeTriangleProgram, NodePointProgram, createEdgeDoubleArrowProgram, createEdgeDoubleClampedProgram };\n"],
  "mappings": "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",
  "names": ["NodePointProgram", "EdgeDoubleClampedProgram", "EdgeLineProgram", "FRAGMENT_SHADER_SOURCE", "EdgeTriangleProgram"]
}
