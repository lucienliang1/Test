import {
  require_getters
} from "./chunk-U4HWKBZX.js";
import {
  require_defaults
} from "./chunk-A3ISJEXD.js";
import {
  c,
  h,
  o
} from "./chunk-QBFRYOH7.js";
import "./chunk-4VMHPG2O.js";
import {
  require_is_graph
} from "./chunk-KWB6VWZC.js";
import "./chunk-5R2YFWNI.js";
import "./chunk-FCKPN5ZG.js";
import "./chunk-KNJF7WWH.js";
import {
  require_react
} from "./chunk-IYWZER4T.js";
import {
  __commonJS,
  __toESM
} from "./chunk-FDBJFBLO.js";

// node_modules/graphology-layout-force/iterate.js
var require_iterate = __commonJS({
  "node_modules/graphology-layout-force/iterate.js"(exports, module) {
    var {
      createNodeValueGetter,
      createEdgeValueGetter
    } = require_getters();
    module.exports = function iterate(graph, nodeStates, params) {
      const { nodeXAttribute: xKey, nodeYAttribute: yKey } = params;
      const { attraction, repulsion, gravity, inertia, maxMove } = params.settings;
      let { shouldSkipNode, shouldSkipEdge, isNodeFixed } = params;
      isNodeFixed = createNodeValueGetter(isNodeFixed);
      shouldSkipNode = createNodeValueGetter(shouldSkipNode, false);
      shouldSkipEdge = createEdgeValueGetter(shouldSkipEdge, false);
      const nodes = graph.filterNodes((n2, attr) => {
        return !shouldSkipNode.fromEntry(n2, attr);
      });
      const adjustedOrder = nodes.length;
      for (let i = 0; i < adjustedOrder; i++) {
        const n2 = nodes[i];
        const attr = graph.getNodeAttributes(n2);
        const nodeState = nodeStates[n2];
        if (!nodeState)
          nodeStates[n2] = {
            dx: 0,
            dy: 0,
            x: attr[xKey] || 0,
            y: attr[yKey] || 0
          };
        else
          nodeStates[n2] = {
            dx: nodeState.dx * inertia,
            dy: nodeState.dy * inertia,
            x: attr[xKey] || 0,
            y: attr[yKey] || 0
          };
      }
      if (repulsion)
        for (let i = 0; i < adjustedOrder; i++) {
          const n1 = nodes[i];
          const n1State = nodeStates[n1];
          for (let j = i + 1; j < adjustedOrder; j++) {
            const n2 = nodes[j];
            const n2State = nodeStates[n2];
            const dx = n2State.x - n1State.x;
            const dy = n2State.y - n1State.y;
            const distance = Math.sqrt(dx * dx + dy * dy) || 1;
            const repulsionX = repulsion / distance * dx;
            const repulsionY = repulsion / distance * dy;
            n1State.dx -= repulsionX;
            n1State.dy -= repulsionY;
            n2State.dx += repulsionX;
            n2State.dy += repulsionY;
          }
        }
      if (attraction)
        graph.forEachEdge(
          (edge, attr, source, target, sourceAttr, targetAttr, undirected) => {
            if (source === target) return;
            if (shouldSkipNode.fromEntry(source, sourceAttr) || shouldSkipNode.fromEntry(target, targetAttr))
              return;
            if (shouldSkipEdge.fromEntry(
              edge,
              attr,
              source,
              target,
              sourceAttr,
              targetAttr,
              undirected
            ))
              return;
            const n1State = nodeStates[source];
            const n2State = nodeStates[target];
            const dx = n2State.x - n1State.x;
            const dy = n2State.y - n1State.y;
            const distance = Math.sqrt(dx * dx + dy * dy) || 1;
            const attractionX = attraction * distance * dx;
            const attractionY = attraction * distance * dy;
            n1State.dx += attractionX;
            n1State.dy += attractionY;
            n2State.dx -= attractionX;
            n2State.dy -= attractionY;
          }
        );
      if (gravity)
        for (let i = 0; i < adjustedOrder; i++) {
          const n2 = nodes[i];
          const nodeState = nodeStates[n2];
          const { x, y } = nodeState;
          const distance = Math.sqrt(x * x + y * y) || 1;
          nodeStates[n2].dx -= x * gravity * distance;
          nodeStates[n2].dy -= y * gravity * distance;
        }
      const converged = false;
      for (let i = 0; i < adjustedOrder; i++) {
        const n2 = nodes[i];
        const nodeState = nodeStates[n2];
        const distance = Math.sqrt(
          nodeState.dx * nodeState.dx + nodeState.dy * nodeState.dy
        );
        if (distance > maxMove) {
          nodeState.dx *= maxMove / distance;
          nodeState.dy *= maxMove / distance;
        }
        if (!isNodeFixed.fromGraph(graph, n2)) {
          nodeState.x += nodeState.dx;
          nodeState.y += nodeState.dy;
          nodeState.fixed = false;
        } else {
          nodeState.fixed = true;
        }
      }
      return { converged };
    };
  }
});

// node_modules/graphology-layout-force/helpers.js
var require_helpers = __commonJS({
  "node_modules/graphology-layout-force/helpers.js"(exports) {
    exports.assignLayoutChanges = function(graph, nodeStates, params) {
      const { nodeXAttribute: x, nodeYAttribute: y } = params;
      graph.updateEachNodeAttributes(
        (n2, attr) => {
          const state = nodeStates[n2];
          if (!state || state.fixed) return attr;
          attr[x] = state.x;
          attr[y] = state.y;
          return attr;
        },
        { attributes: ["x", "y"] }
      );
    };
    exports.collectLayoutChanges = function(nodeStates) {
      const mapping = {};
      for (const n2 in nodeStates) {
        const state = nodeStates[n2];
        mapping[n2] = { x: state.x, y: state.y };
      }
      return mapping;
    };
  }
});

// node_modules/graphology-layout-force/defaults.js
var require_defaults2 = __commonJS({
  "node_modules/graphology-layout-force/defaults.js"(exports, module) {
    module.exports = {
      nodeXAttribute: "x",
      nodeYAttribute: "y",
      isNodeFixed: "fixed",
      shouldSkipNode: null,
      shouldSkipEdge: null,
      settings: {
        attraction: 5e-4,
        repulsion: 0.1,
        gravity: 1e-4,
        inertia: 0.6,
        maxMove: 200
      }
    };
  }
});

// node_modules/graphology-layout-force/index.js
var require_graphology_layout_force = __commonJS({
  "node_modules/graphology-layout-force/index.js"(exports, module) {
    var isGraph = require_is_graph();
    var resolveDefaults = require_defaults();
    var iterate = require_iterate();
    var helpers = require_helpers();
    var DEFAULTS = require_defaults2();
    function abstractSynchronousLayout(assign, graph, params) {
      if (!isGraph(graph))
        throw new Error(
          "graphology-layout-force: the given graph is not a valid graphology instance."
        );
      if (typeof params === "number") params = { maxIterations: params };
      else params = params || {};
      const maxIterations = params.maxIterations;
      params = resolveDefaults(params, DEFAULTS);
      if (typeof maxIterations !== "number" || maxIterations <= 0)
        throw new Error(
          "graphology-layout-force: you should provide a positive number of maximum iterations."
        );
      const nodeStates = {};
      let result = null;
      let i;
      for (i = 0; i < maxIterations; i++) {
        result = iterate(graph, nodeStates, params);
        if (result.converged) break;
      }
      if (assign) {
        helpers.assignLayoutChanges(graph, nodeStates, params);
        return;
      }
      return helpers.collectLayoutChanges(nodeStates);
    }
    var synchronousLayout = abstractSynchronousLayout.bind(null, false);
    synchronousLayout.assign = abstractSynchronousLayout.bind(null, true);
    module.exports = synchronousLayout;
  }
});

// node_modules/graphology-layout-force/worker.js
var require_worker = __commonJS({
  "node_modules/graphology-layout-force/worker.js"(exports, module) {
    var isGraph = require_is_graph();
    var resolveDefaults = require_defaults();
    var iterate = require_iterate();
    var helpers = require_helpers();
    var DEFAULTS = require_defaults2();
    function ForceSupervisor(graph, params) {
      if (!isGraph(graph))
        throw new Error(
          "graphology-layout-force/worker: the given graph is not a valid graphology instance."
        );
      params = resolveDefaults(params, DEFAULTS);
      this.callbacks = {};
      if (params.onConverged) this.callbacks.onConverged = params.onConverged;
      this.graph = graph;
      this.params = params;
      this.nodeStates = {};
      this.frameID = null;
      this.running = false;
      this.killed = false;
    }
    ForceSupervisor.prototype.isRunning = function() {
      return this.running;
    };
    ForceSupervisor.prototype.runFrame = function() {
      let { converged } = iterate(this.graph, this.nodeStates, this.params);
      helpers.assignLayoutChanges(this.graph, this.nodeStates, this.params);
      converged = false;
      if (converged) {
        if (this.callbacks.onConverged) this.callbacks.onConverged();
        this.stop();
      } else {
        this.frameID = window.requestAnimationFrame(() => this.runFrame());
      }
    };
    ForceSupervisor.prototype.stop = function() {
      this.running = false;
      if (this.frameID !== null) {
        window.cancelAnimationFrame(this.frameID);
        this.frameID = null;
      }
      return this;
    };
    ForceSupervisor.prototype.start = function() {
      if (this.killed)
        throw new Error("graphology-layout-force/worker.start: layout was killed.");
      if (this.running) return;
      this.running = true;
      this.runFrame();
    };
    ForceSupervisor.prototype.kill = function() {
      this.stop();
      delete this.nodeStates;
      this.killed = true;
    };
    module.exports = ForceSupervisor;
  }
});

// node_modules/@react-sigma/layout-force/lib/react-sigma_layout-force.esm.min.js
var import_graphology_layout_force = __toESM(require_graphology_layout_force());
var import_worker = __toESM(require_worker());
var import_react = __toESM(require_react());
function n(r = { maxIterations: 100 }) {
  return o(import_graphology_layout_force.default, r);
}
function s(o2 = {}) {
  return c(import_worker.default, o2);
}
var c2 = ({ id: o2, className: r, style: e2, settings: a2 = {}, autoRunFor: n2, children: c3, labels: i }) => {
  const m = { id: o2, className: r, style: e2, autoRunFor: n2, labels: i, layout: s(a2) };
  return import_react.default.createElement(h, Object.assign({}, m), c3);
};
export {
  c2 as LayoutForceControl,
  n as useLayoutForce,
  s as useWorkerLayoutForce
};
//# sourceMappingURL=@react-sigma_layout-force.js.map
