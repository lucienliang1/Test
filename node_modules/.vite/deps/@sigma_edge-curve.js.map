{
  "version": 3,
  "sources": ["../../@sigma/edge-curve/dist/sigma-edge-curve.esm.js"],
  "sourcesContent": ["import { EdgeProgram, DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS } from 'sigma/rendering';\nimport { floatColor } from 'sigma/utils';\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\n\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\n\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\n\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\n\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\n\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\n\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\n\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\n\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\n\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\n\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\n\nfunction getCurvePoint(t, p0, p1, p2) {\n  var x = Math.pow(1 - t, 2) * p0.x + 2 * (1 - t) * t * p1.x + Math.pow(t, 2) * p2.x;\n  var y = Math.pow(1 - t, 2) * p0.y + 2 * (1 - t) * t * p1.y + Math.pow(t, 2) * p2.y;\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction getCurveLength(p0, p1, p2) {\n  var steps = 20;\n  var length = 0;\n  var lastPoint = p0;\n  for (var i = 0; i < steps; i++) {\n    var point = getCurvePoint((i + 1) / steps, p0, p1, p2);\n    length += Math.sqrt(Math.pow(lastPoint.x - point.x, 2) + Math.pow(lastPoint.y - point.y, 2));\n    lastPoint = point;\n  }\n  return length;\n}\nfunction createDrawCurvedEdgeLabel(_ref) {\n  var curvatureAttribute = _ref.curvatureAttribute,\n    defaultCurvature = _ref.defaultCurvature,\n    _ref$keepLabelUpright = _ref.keepLabelUpright,\n    keepLabelUpright = _ref$keepLabelUpright === void 0 ? true : _ref$keepLabelUpright;\n  return function (context, edgeData, sourceData, targetData, settings) {\n    var size = settings.edgeLabelSize,\n      curvature = edgeData[curvatureAttribute] || defaultCurvature,\n      font = settings.edgeLabelFont,\n      weight = settings.edgeLabelWeight,\n      color = settings.edgeLabelColor.attribute ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\" : settings.edgeLabelColor.color;\n    var label = edgeData.label;\n    if (!label) return;\n    context.fillStyle = color;\n    context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n\n    // Computing positions without considering nodes sizes:\n    var ltr = !keepLabelUpright || sourceData.x < targetData.x;\n    var sourceX = ltr ? sourceData.x : targetData.x;\n    var sourceY = ltr ? sourceData.y : targetData.y;\n    var targetX = ltr ? targetData.x : sourceData.x;\n    var targetY = ltr ? targetData.y : sourceData.y;\n    var centerX = (sourceX + targetX) / 2;\n    var centerY = (sourceY + targetY) / 2;\n    var diffX = targetX - sourceX;\n    var diffY = targetY - sourceY;\n    var diff = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));\n    // Anchor point:\n    var orientation = ltr ? 1 : -1;\n    var anchorX = centerX + diffY * curvature * orientation;\n    var anchorY = centerY - diffX * curvature * orientation;\n\n    // Adapt curve points to edge thickness:\n    var offset = edgeData.size * 0.7 + 5;\n    var sourceOffsetVector = {\n      x: anchorY - sourceY,\n      y: -(anchorX - sourceX)\n    };\n    var sourceOffsetVectorLength = Math.sqrt(Math.pow(sourceOffsetVector.x, 2) + Math.pow(sourceOffsetVector.y, 2));\n    var targetOffsetVector = {\n      x: targetY - anchorY,\n      y: -(targetX - anchorX)\n    };\n    var targetOffsetVectorLength = Math.sqrt(Math.pow(targetOffsetVector.x, 2) + Math.pow(targetOffsetVector.y, 2));\n    sourceX += offset * sourceOffsetVector.x / sourceOffsetVectorLength;\n    sourceY += offset * sourceOffsetVector.y / sourceOffsetVectorLength;\n    targetX += offset * targetOffsetVector.x / targetOffsetVectorLength;\n    targetY += offset * targetOffsetVector.y / targetOffsetVectorLength;\n    // For anchor, the vector is simpler, so it is inlined:\n    anchorX += offset * diffY / diff;\n    anchorY -= offset * diffX / diff;\n\n    // Compute curve length:\n    var anchorPoint = {\n      x: anchorX,\n      y: anchorY\n    };\n    var sourcePoint = {\n      x: sourceX,\n      y: sourceY\n    };\n    var targetPoint = {\n      x: targetX,\n      y: targetY\n    };\n    var curveLength = getCurveLength(sourcePoint, anchorPoint, targetPoint);\n    if (curveLength < sourceData.size + targetData.size) return;\n\n    // Handling ellipsis\n    var textLength = context.measureText(label).width;\n    var availableTextLength = curveLength - sourceData.size - targetData.size;\n    if (textLength > availableTextLength) {\n      var ellipsis = \"…\";\n      label = label + ellipsis;\n      textLength = context.measureText(label).width;\n      while (textLength > availableTextLength && label.length > 1) {\n        label = label.slice(0, -2) + ellipsis;\n        textLength = context.measureText(label).width;\n      }\n      if (label.length < 4) return;\n    }\n\n    // Measure each character:\n    var charactersLengthCache = {};\n    for (var i = 0, length = label.length; i < length; i++) {\n      var character = label[i];\n      if (!charactersLengthCache[character]) {\n        charactersLengthCache[character] = context.measureText(character).width * (1 + curvature * 0.35);\n      }\n    }\n\n    // Draw each character:\n    var t = 0.5 - textLength / curveLength / 2;\n    for (var _i = 0, _length = label.length; _i < _length; _i++) {\n      var _character = label[_i];\n      var point = getCurvePoint(t, sourcePoint, anchorPoint, targetPoint);\n      var tangentX = 2 * (1 - t) * (anchorX - sourceX) + 2 * t * (targetX - anchorX);\n      var tangentY = 2 * (1 - t) * (anchorY - sourceY) + 2 * t * (targetY - anchorY);\n      var angle = Math.atan2(tangentY, tangentX);\n      context.save();\n      context.translate(point.x, point.y);\n      context.rotate(angle);\n\n      // Dessiner le caractère\n      context.fillText(_character, 0, 0);\n      context.restore();\n      t += charactersLengthCache[_character] / curveLength;\n    }\n  };\n}\n\nfunction getFragmentShader(_ref) {\n  var arrowHead = _ref.arrowHead;\n  var hasTargetArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"target\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n  var hasSourceArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"source\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n\n  // language=GLSL\n  var SHADER = /*glsl*/\"\\nprecision highp float;\\n\\nvarying vec4 v_color;\\nvarying float v_thickness;\\nvarying float v_feather;\\nvarying vec2 v_cpA;\\nvarying vec2 v_cpB;\\nvarying vec2 v_cpC;\\n\".concat(hasTargetArrowHead ? \"\\nvarying float v_targetSize;\\nvarying vec2 v_targetPoint;\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"\\nvarying float v_sourceSize;\\nvarying vec2 v_sourcePoint;\" : \"\", \"\\n\").concat(arrowHead ? \"\\nuniform float u_lengthToThicknessRatio;\\nuniform float u_widenessToThicknessRatio;\" : \"\", \"\\n\\nfloat det(vec2 a, vec2 b) {\\n  return a.x * b.y - b.x * a.y;\\n}\\n\\nvec2 getDistanceVector(vec2 b0, vec2 b1, vec2 b2) {\\n  float a = det(b0, b2), b = 2.0 * det(b1, b0), d = 2.0 * det(b2, b1);\\n  float f = b * d - a * a;\\n  vec2 d21 = b2 - b1, d10 = b1 - b0, d20 = b2 - b0;\\n  vec2 gf = 2.0 * (b * d21 + d * d10 + a * d20);\\n  gf = vec2(gf.y, -gf.x);\\n  vec2 pp = -f * gf / dot(gf, gf);\\n  vec2 d0p = b0 - pp;\\n  float ap = det(d0p, d20), bp = 2.0 * det(d10, d0p);\\n  float t = clamp((ap + bp) / (2.0 * a + b + d), 0.0, 1.0);\\n  return mix(mix(b0, b1, t), mix(b1, b2, t), t);\\n}\\n\\nfloat distToQuadraticBezierCurve(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\\n  return length(getDistanceVector(b0 - p, b1 - p, b2 - p));\\n}\\n\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  float dist = distToQuadraticBezierCurve(gl_FragCoord.xy, v_cpA, v_cpB, v_cpC);\\n  float thickness = v_thickness;\\n\").concat(hasTargetArrowHead ? \"\\n  float distToTarget = length(gl_FragCoord.xy - v_targetPoint);\\n  float targetArrowLength = v_targetSize + thickness * u_lengthToThicknessRatio;\\n  if (distToTarget < targetArrowLength) {\\n    thickness = (distToTarget - v_targetSize) / (targetArrowLength - v_targetSize) * u_widenessToThicknessRatio * thickness;\\n  }\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"\\n  float distToSource = length(gl_FragCoord.xy - v_sourcePoint);\\n  float sourceArrowLength = v_sourceSize + thickness * u_lengthToThicknessRatio;\\n  if (distToSource < sourceArrowLength) {\\n    thickness = (distToSource - v_sourceSize) / (sourceArrowLength - v_sourceSize) * u_widenessToThicknessRatio * thickness;\\n  }\" : \"\", \"\\n\\n  float halfThickness = thickness / 2.0;\\n  if (dist < halfThickness) {\\n    #ifdef PICKING_MODE\\n    gl_FragColor = v_color;\\n    #else\\n    float t = smoothstep(\\n      halfThickness - v_feather,\\n      halfThickness,\\n      dist\\n    );\\n\\n    gl_FragColor = mix(v_color, transparent, t);\\n    #endif\\n  } else {\\n    gl_FragColor = transparent;\\n  }\\n}\\n\");\n  return SHADER;\n}\n\nfunction getVertexShader(_ref) {\n  var arrowHead = _ref.arrowHead;\n  var hasTargetArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"target\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n  var hasSourceArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"source\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n\n  // language=GLSL\n  var SHADER = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute float a_direction;\\nattribute float a_thickness;\\nattribute vec2 a_source;\\nattribute vec2 a_target;\\nattribute float a_current;\\nattribute float a_curvature;\\n\".concat(hasTargetArrowHead ? \"attribute float a_targetSize;\\n\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"attribute float a_sourceSize;\\n\" : \"\", \"\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform vec2 u_dimensions;\\nuniform float u_minEdgeThickness;\\nuniform float u_feather;\\n\\nvarying vec4 v_color;\\nvarying float v_thickness;\\nvarying float v_feather;\\nvarying vec2 v_cpA;\\nvarying vec2 v_cpB;\\nvarying vec2 v_cpC;\\n\").concat(hasTargetArrowHead ? \"\\nvarying float v_targetSize;\\nvarying vec2 v_targetPoint;\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"\\nvarying float v_sourceSize;\\nvarying vec2 v_sourcePoint;\" : \"\", \"\\n\").concat(arrowHead ? \"\\nuniform float u_widenessToThicknessRatio;\" : \"\", \"\\n\\nconst float bias = 255.0 / 254.0;\\nconst float epsilon = 0.7;\\n\\nvec2 clipspaceToViewport(vec2 pos, vec2 dimensions) {\\n  return vec2(\\n    (pos.x + 1.0) * dimensions.x / 2.0,\\n    (pos.y + 1.0) * dimensions.y / 2.0\\n  );\\n}\\n\\nvec2 viewportToClipspace(vec2 pos, vec2 dimensions) {\\n  return vec2(\\n    pos.x / dimensions.x * 2.0 - 1.0,\\n    pos.y / dimensions.y * 2.0 - 1.0\\n  );\\n}\\n\\nvoid main() {\\n  float minThickness = u_minEdgeThickness;\\n\\n  // Selecting the correct position\\n  // Branchless \\\"position = a_source if a_current == 1.0 else a_target\\\"\\n  vec2 position = a_source * max(0.0, a_current) + a_target * max(0.0, 1.0 - a_current);\\n  position = (u_matrix * vec3(position, 1)).xy;\\n\\n  vec2 source = (u_matrix * vec3(a_source, 1)).xy;\\n  vec2 target = (u_matrix * vec3(a_target, 1)).xy;\\n\\n  vec2 viewportPosition = clipspaceToViewport(position, u_dimensions);\\n  vec2 viewportSource = clipspaceToViewport(source, u_dimensions);\\n  vec2 viewportTarget = clipspaceToViewport(target, u_dimensions);\\n\\n  vec2 delta = viewportTarget.xy - viewportSource.xy;\\n  float len = length(delta);\\n  vec2 normal = vec2(-delta.y, delta.x) * a_direction;\\n  vec2 unitNormal = normal / len;\\n  float boundingBoxThickness = len * a_curvature;\\n\\n  float curveThickness = max(minThickness, a_thickness / u_sizeRatio);\\n  v_thickness = curveThickness * u_pixelRatio;\\n  v_feather = u_feather;\\n\\n  v_cpA = viewportSource;\\n  v_cpB = 0.5 * (viewportSource + viewportTarget) + unitNormal * a_direction * boundingBoxThickness;\\n  v_cpC = viewportTarget;\\n\\n  vec2 viewportOffsetPosition = (\\n    viewportPosition +\\n    unitNormal * (boundingBoxThickness / 2.0 + sign(boundingBoxThickness) * (\").concat(arrowHead ? \"curveThickness * u_widenessToThicknessRatio\" : \"curveThickness\", \" + epsilon)) *\\n    max(0.0, a_direction) // NOTE: cutting the bounding box in half to avoid overdraw\\n  );\\n\\n  position = viewportToClipspace(viewportOffsetPosition, u_dimensions);\\n  gl_Position = vec4(position, 0, 1);\\n    \\n\").concat(hasTargetArrowHead ? \"\\n  v_targetSize = a_targetSize * u_pixelRatio / u_sizeRatio;\\n  v_targetPoint = viewportTarget;\\n\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"\\n  v_sourceSize = a_sourceSize * u_pixelRatio / u_sizeRatio;\\n  v_sourcePoint = viewportSource;\\n\" : \"\", \"\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\");\n  return SHADER;\n}\n\nvar DEFAULT_EDGE_CURVATURE = 0.25;\nvar DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS = {\n  arrowHead: null,\n  curvatureAttribute: \"curvature\",\n  defaultCurvature: DEFAULT_EDGE_CURVATURE\n};\n\n/**\n * This function helps to identify parallel edges, to adjust their curvatures.\n */\nvar DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS = {\n  edgeIndexAttribute: \"parallelIndex\",\n  edgeMinIndexAttribute: \"parallelMinIndex\",\n  edgeMaxIndexAttribute: \"parallelMaxIndex\"\n};\nfunction indexParallelEdgesIndex(graph, options) {\n  var opts = _objectSpread2(_objectSpread2({}, DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS), options || {});\n  var nodeIDsMapping = {};\n  var edgeDirectedIDsMapping = {};\n  var edgeUndirectedIDsMapping = {};\n\n  // Normalize IDs:\n  var incr = 0;\n  graph.forEachNode(function (node) {\n    nodeIDsMapping[node] = ++incr + \"\";\n  });\n  graph.forEachEdge(function (edge, _attrs, source, target) {\n    var sourceId = nodeIDsMapping[source];\n    var targetId = nodeIDsMapping[target];\n    var directedId = [sourceId, targetId].join(\"-\");\n    edgeDirectedIDsMapping[edge] = directedId;\n    edgeUndirectedIDsMapping[directedId] = [sourceId, targetId].sort().join(\"-\");\n  });\n\n  // Index edge unique IDs, only based on their extremities:\n  var directedIndex = {};\n  var undirectedIndex = {};\n  graph.forEachEdge(function (edge) {\n    var directedId = edgeDirectedIDsMapping[edge];\n    var undirectedId = edgeUndirectedIDsMapping[directedId];\n    directedIndex[directedId] = directedIndex[directedId] || [];\n    directedIndex[directedId].push(edge);\n    undirectedIndex[undirectedId] = undirectedIndex[undirectedId] || [];\n    undirectedIndex[undirectedId].push(edge);\n  });\n\n  // Store index attributes:\n  for (var directedId in directedIndex) {\n    var edges = directedIndex[directedId];\n    var directedCount = edges.length;\n    var undirectedCount = undirectedIndex[edgeUndirectedIDsMapping[directedId]].length;\n\n    // If the edge is alone, in both side:\n    if (directedCount === 1 && undirectedCount === 1) {\n      var edge = edges[0];\n      graph.setEdgeAttribute(edge, opts.edgeIndexAttribute, null);\n      graph.setEdgeAttribute(edge, opts.edgeMaxIndexAttribute, null);\n    }\n\n    // If the edge is alone, but there is at least one edge in the opposite direction:\n    else if (directedCount === 1) {\n      var _edge = edges[0];\n      graph.setEdgeAttribute(_edge, opts.edgeIndexAttribute, 1);\n      graph.setEdgeAttribute(_edge, opts.edgeMaxIndexAttribute, 1);\n    }\n\n    // If the edge is not alone, and all edges are in the same direction:\n    else if (directedCount === undirectedCount) {\n      var max = (directedCount - 1) / 2;\n      var min = -max;\n      for (var i = 0; i < directedCount; i++) {\n        var _edge2 = edges[i];\n        var edgeIndex = -(directedCount - 1) / 2 + i;\n        graph.setEdgeAttribute(_edge2, opts.edgeIndexAttribute, edgeIndex);\n        graph.setEdgeAttribute(_edge2, opts.edgeMinIndexAttribute, min);\n        graph.setEdgeAttribute(_edge2, opts.edgeMaxIndexAttribute, max);\n      }\n    }\n\n    // If the edge is not alone, and there are edges in both directions:\n    else {\n      for (var _i = 0; _i < directedCount; _i++) {\n        var _edge3 = edges[_i];\n        graph.setEdgeAttribute(_edge3, opts.edgeIndexAttribute, _i + 1);\n        graph.setEdgeAttribute(_edge3, opts.edgeMaxIndexAttribute, directedCount);\n      }\n    }\n  }\n}\n\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nfunction createEdgeCurveProgram(inputOptions) {\n  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS), inputOptions || {});\n  var _ref = options,\n    arrowHead = _ref.arrowHead,\n    curvatureAttribute = _ref.curvatureAttribute,\n    drawLabel = _ref.drawLabel;\n  var hasTargetArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"target\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n  var hasSourceArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"source\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n  var UNIFORMS = [\"u_matrix\", \"u_sizeRatio\", \"u_dimensions\", \"u_pixelRatio\", \"u_feather\", \"u_minEdgeThickness\"].concat(_toConsumableArray(arrowHead ? [\"u_lengthToThicknessRatio\", \"u_widenessToThicknessRatio\"] : []));\n  return /*#__PURE__*/function (_EdgeProgram) {\n    _inherits(EdgeCurveProgram, _EdgeProgram);\n    function EdgeCurveProgram() {\n      var _this;\n      _classCallCheck(this, EdgeCurveProgram);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _callSuper(this, EdgeCurveProgram, [].concat(args));\n      _defineProperty(_assertThisInitialized(_this), \"drawLabel\", drawLabel || createDrawCurvedEdgeLabel(options));\n      return _this;\n    }\n    _createClass(EdgeCurveProgram, [{\n      key: \"getDefinition\",\n      value: function getDefinition() {\n        return {\n          VERTICES: 6,\n          VERTEX_SHADER_SOURCE: getVertexShader(options),\n          FRAGMENT_SHADER_SOURCE: getFragmentShader(options),\n          METHOD: WebGLRenderingContext.TRIANGLES,\n          UNIFORMS: UNIFORMS,\n          ATTRIBUTES: [{\n            name: \"a_source\",\n            size: 2,\n            type: FLOAT\n          }, {\n            name: \"a_target\",\n            size: 2,\n            type: FLOAT\n          }].concat(_toConsumableArray(hasTargetArrowHead ? [{\n            name: \"a_targetSize\",\n            size: 1,\n            type: FLOAT\n          }] : []), _toConsumableArray(hasSourceArrowHead ? [{\n            name: \"a_sourceSize\",\n            size: 1,\n            type: FLOAT\n          }] : []), [{\n            name: \"a_thickness\",\n            size: 1,\n            type: FLOAT\n          }, {\n            name: \"a_curvature\",\n            size: 1,\n            type: FLOAT\n          }, {\n            name: \"a_color\",\n            size: 4,\n            type: UNSIGNED_BYTE,\n            normalized: true\n          }, {\n            name: \"a_id\",\n            size: 4,\n            type: UNSIGNED_BYTE,\n            normalized: true\n          }]),\n          CONSTANT_ATTRIBUTES: [{\n            name: \"a_current\",\n            size: 1,\n            type: FLOAT\n          },\n          // TODO: could optimize to bool\n          {\n            name: \"a_direction\",\n            size: 1,\n            type: FLOAT\n          } // TODO: could optimize to byte\n          ],\n          CONSTANT_DATA: [[0, 1], [0, -1], [1, 1], [0, -1], [1, 1], [1, -1]]\n        };\n      }\n    }, {\n      key: \"processVisibleItem\",\n      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n        var _data;\n        var thickness = data.size || 1;\n        var x1 = sourceData.x;\n        var y1 = sourceData.y;\n        var x2 = targetData.x;\n        var y2 = targetData.y;\n        var color = floatColor(data.color);\n        var curvature = (_data = data[curvatureAttribute]) !== null && _data !== void 0 ? _data : DEFAULT_EDGE_CURVATURE;\n        var array = this.array;\n\n        // First point\n        array[startIndex++] = x1;\n        array[startIndex++] = y1;\n        array[startIndex++] = x2;\n        array[startIndex++] = y2;\n        if (hasTargetArrowHead) array[startIndex++] = targetData.size;\n        if (hasSourceArrowHead) array[startIndex++] = sourceData.size;\n        array[startIndex++] = thickness;\n        array[startIndex++] = curvature;\n        array[startIndex++] = color;\n        array[startIndex++] = edgeIndex;\n      }\n    }, {\n      key: \"setUniforms\",\n      value: function setUniforms(params, _ref2) {\n        var gl = _ref2.gl,\n          uniformLocations = _ref2.uniformLocations;\n        var u_matrix = uniformLocations.u_matrix,\n          u_pixelRatio = uniformLocations.u_pixelRatio,\n          u_feather = uniformLocations.u_feather,\n          u_sizeRatio = uniformLocations.u_sizeRatio,\n          u_dimensions = uniformLocations.u_dimensions,\n          u_minEdgeThickness = uniformLocations.u_minEdgeThickness;\n        gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n        gl.uniform1f(u_pixelRatio, params.pixelRatio);\n        gl.uniform1f(u_sizeRatio, params.sizeRatio);\n        gl.uniform1f(u_feather, params.antiAliasingFeather);\n        gl.uniform2f(u_dimensions, params.width * params.pixelRatio, params.height * params.pixelRatio);\n        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n        if (arrowHead) {\n          var u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio,\n            u_widenessToThicknessRatio = uniformLocations.u_widenessToThicknessRatio;\n          gl.uniform1f(u_lengthToThicknessRatio, arrowHead.lengthToThicknessRatio);\n          gl.uniform1f(u_widenessToThicknessRatio, arrowHead.widenessToThicknessRatio);\n        }\n      }\n    }]);\n    return EdgeCurveProgram;\n  }(EdgeProgram);\n}\n\nvar EdgeCurveProgram = createEdgeCurveProgram();\nvar EdgeCurvedArrowProgram = createEdgeCurveProgram({\n  arrowHead: DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS\n});\nvar EdgeCurvedDoubleArrowProgram = createEdgeCurveProgram({\n  arrowHead: _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS), {}, {\n    extremity: \"both\"\n  })\n});\n\nexport { DEFAULT_EDGE_CURVATURE, DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS, DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS, EdgeCurvedArrowProgram, EdgeCurvedDoubleArrowProgram, createDrawCurvedEdgeLabel, createEdgeCurveProgram, EdgeCurveProgram as default, indexParallelEdgesIndex };\n"],
  "mappings": "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",
  "names": ["r", "t", "e", "edge", "directedId", "EdgeCurveProgram"]
}
