{
  "version": 3,
  "sources": ["../../graphology-layout-force/iterate.js", "../../graphology-layout-force/helpers.js", "../../graphology-layout-force/defaults.js", "../../graphology-layout-force/index.js", "../../graphology-layout-force/worker.js", "../../@react-sigma/layout-force/src/useLayoutForce.ts", "../../@react-sigma/layout-force/src/useWorkerLayoutForce.ts", "../../@react-sigma/layout-force/src/LayoutForceControl.tsx"],
  "sourcesContent": ["/**\n * Graphology Force Layout Iteration\n * ==================================\n *\n * Function describing a single iteration of the force layout.\n */\nconst {\n  createNodeValueGetter,\n  createEdgeValueGetter\n} = require('graphology-utils/getters');\n\n// const EPSILON = -Infinity;\n\n// function isVeryCloseToZero(x) {\n//   return Math.abs(x) < EPSILON;\n// }\n\nmodule.exports = function iterate(graph, nodeStates, params) {\n  const {nodeXAttribute: xKey, nodeYAttribute: yKey} = params;\n  const {attraction, repulsion, gravity, inertia, maxMove} = params.settings;\n\n  let {shouldSkipNode, shouldSkipEdge, isNodeFixed} = params;\n\n  isNodeFixed = createNodeValueGetter(isNodeFixed);\n  shouldSkipNode = createNodeValueGetter(shouldSkipNode, false);\n  shouldSkipEdge = createEdgeValueGetter(shouldSkipEdge, false);\n\n  const nodes = graph.filterNodes((n, attr) => {\n    return !shouldSkipNode.fromEntry(n, attr);\n  });\n\n  const adjustedOrder = nodes.length;\n\n  // Check nodeStatess and inertia\n  for (let i = 0; i < adjustedOrder; i++) {\n    const n = nodes[i];\n    const attr = graph.getNodeAttributes(n);\n    const nodeState = nodeStates[n];\n\n    if (!nodeState)\n      nodeStates[n] = {\n        dx: 0,\n        dy: 0,\n        x: attr[xKey] || 0,\n        y: attr[yKey] || 0\n      };\n    else\n      nodeStates[n] = {\n        dx: nodeState.dx * inertia,\n        dy: nodeState.dy * inertia,\n        x: attr[xKey] || 0,\n        y: attr[yKey] || 0\n      };\n  }\n\n  // Repulsion\n  if (repulsion)\n    for (let i = 0; i < adjustedOrder; i++) {\n      const n1 = nodes[i];\n      const n1State = nodeStates[n1];\n\n      for (let j = i + 1; j < adjustedOrder; j++) {\n        const n2 = nodes[j];\n        const n2State = nodeStates[n2];\n\n        // Compute distance:\n        const dx = n2State.x - n1State.x;\n        const dy = n2State.y - n1State.y;\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\n\n        // Repulse nodes relatively to 1 / distance:\n        const repulsionX = (repulsion / distance) * dx;\n        const repulsionY = (repulsion / distance) * dy;\n        n1State.dx -= repulsionX;\n        n1State.dy -= repulsionY;\n        n2State.dx += repulsionX;\n        n2State.dy += repulsionY;\n      }\n    }\n\n  // Attraction\n  if (attraction)\n    graph.forEachEdge(\n      (edge, attr, source, target, sourceAttr, targetAttr, undirected) => {\n        if (source === target) return;\n\n        if (\n          shouldSkipNode.fromEntry(source, sourceAttr) ||\n          shouldSkipNode.fromEntry(target, targetAttr)\n        )\n          return;\n\n        if (\n          shouldSkipEdge.fromEntry(\n            edge,\n            attr,\n            source,\n            target,\n            sourceAttr,\n            targetAttr,\n            undirected\n          )\n        )\n          return;\n\n        const n1State = nodeStates[source];\n        const n2State = nodeStates[target];\n\n        // Compute distance:\n        const dx = n2State.x - n1State.x;\n        const dy = n2State.y - n1State.y;\n\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\n\n        // Attract nodes relatively to their distance:\n        const attractionX = attraction * distance * dx;\n        const attractionY = attraction * distance * dy;\n        n1State.dx += attractionX;\n        n1State.dy += attractionY;\n        n2State.dx -= attractionX;\n        n2State.dy -= attractionY;\n      }\n    );\n\n  // Gravity\n  if (gravity)\n    for (let i = 0; i < adjustedOrder; i++) {\n      const n = nodes[i];\n      const nodeState = nodeStates[n];\n\n      // Attract nodes to [0, 0] relatively to the distance:\n      const {x, y} = nodeState;\n      const distance = Math.sqrt(x * x + y * y) || 1;\n      nodeStates[n].dx -= x * gravity * distance;\n      nodeStates[n].dy -= y * gravity * distance;\n    }\n\n  // Apply forces\n  const converged = false;\n\n  for (let i = 0; i < adjustedOrder; i++) {\n    const n = nodes[i];\n    const nodeState = nodeStates[n];\n\n    const distance = Math.sqrt(\n      nodeState.dx * nodeState.dx + nodeState.dy * nodeState.dy\n    );\n\n    if (distance > maxMove) {\n      nodeState.dx *= maxMove / distance;\n      nodeState.dy *= maxMove / distance;\n    }\n\n    // if (!isVeryCloseToZero(nodeState.dx) || !isVeryCloseToZero(nodeState.dy)) {\n    //   converged = false;\n    // }\n\n    if (!isNodeFixed.fromGraph(graph, n)) {\n      nodeState.x += nodeState.dx;\n      nodeState.y += nodeState.dy;\n      nodeState.fixed = false;\n    } else {\n      nodeState.fixed = true;\n    }\n\n    // NOTE: possibility to assign here to save one loop in the future\n  }\n\n  return {converged};\n};\n", "/**\n * Graphology Force Layout Helpers\n * ================================\n *\n * Miscellaneous helper functions related to the force layout.\n */\nexports.assignLayoutChanges = function (graph, nodeStates, params) {\n  const {nodeXAttribute: x, nodeYAttribute: y} = params;\n\n  graph.updateEachNodeAttributes(\n    (n, attr) => {\n      const state = nodeStates[n];\n\n      if (!state || state.fixed) return attr;\n\n      attr[x] = state.x;\n      attr[y] = state.y;\n\n      return attr;\n    },\n    {attributes: ['x', 'y']}\n  );\n};\n\nexports.collectLayoutChanges = function (nodeStates) {\n  const mapping = {};\n\n  for (const n in nodeStates) {\n    const state = nodeStates[n];\n\n    mapping[n] = {x: state.x, y: state.y};\n  }\n\n  return mapping;\n};\n", "/**\n * Graphology Force Layout Defaults\n * =================================\n *\n * Default options & settings used by the library.\n */\nmodule.exports = {\n  nodeXAttribute: 'x',\n  nodeYAttribute: 'y',\n  isNodeFixed: 'fixed',\n  shouldSkipNode: null,\n  shouldSkipEdge: null,\n  settings: {\n    attraction: 0.0005,\n    repulsion: 0.1,\n    gravity: 0.0001,\n    inertia: 0.6,\n    maxMove: 200\n  }\n};\n", "/**\n * Graphology Force Layout\n * ========================\n *\n * A simple force-directed layout algorithm for graphology.\n */\nconst isGraph = require('graphology-utils/is-graph');\nconst resolveDefaults = require('graphology-utils/defaults');\n\nconst iterate = require('./iterate.js');\nconst helpers = require('./helpers.js');\n\nconst DEFAULTS = require('./defaults.js');\n\n/**\n * Asbtract function used to run the layout for a certain number of iterations.\n *\n * @param  {boolean}       assign       - Whether to assign positions.\n * @param  {Graph}         graph        - Target graph.\n * @param  {object|number} params       - If number, params.maxIterations, else:\n * @param  {number}          maxIterations - Maximum number of iterations.\n * @param  {object}          [settings] - Settings.\n * @return {object|undefined}\n */\nfunction abstractSynchronousLayout(assign, graph, params) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout-force: the given graph is not a valid graphology instance.'\n    );\n\n  if (typeof params === 'number') params = {maxIterations: params};\n  else params = params || {};\n\n  const maxIterations = params.maxIterations;\n\n  params = resolveDefaults(params, DEFAULTS);\n\n  if (typeof maxIterations !== 'number' || maxIterations <= 0)\n    throw new Error(\n      'graphology-layout-force: you should provide a positive number of maximum iterations.'\n    );\n\n  // Iteration state\n  const nodeStates = {};\n  let result = null;\n  let i;\n\n  // Iterating\n  for (i = 0; i < maxIterations; i++) {\n    result = iterate(graph, nodeStates, params);\n\n    if (result.converged) break;\n  }\n\n  // Applying\n  if (assign) {\n    helpers.assignLayoutChanges(graph, nodeStates, params);\n    return;\n  }\n\n  return helpers.collectLayoutChanges(nodeStates);\n}\n\n/**\n * Exporting.\n */\nconst synchronousLayout = abstractSynchronousLayout.bind(null, false);\nsynchronousLayout.assign = abstractSynchronousLayout.bind(null, true);\n\nmodule.exports = synchronousLayout;\n", "/**\n * Graphology Force Layout Worker\n * ===============================\n *\n * A worker made for running a force layout live.\n *\n * Note that it does not run in a webworker yet but respect animation frames.\n */\nconst isGraph = require('graphology-utils/is-graph');\nconst resolveDefaults = require('graphology-utils/defaults');\n\nconst iterate = require('./iterate.js');\nconst helpers = require('./helpers.js');\nconst DEFAULTS = require('./defaults.js');\n\nfunction ForceSupervisor(graph, params) {\n  // Validation\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout-force/worker: the given graph is not a valid graphology instance.'\n    );\n\n  params = resolveDefaults(params, DEFAULTS);\n\n  this.callbacks = {};\n\n  if (params.onConverged) this.callbacks.onConverged = params.onConverged;\n\n  this.graph = graph;\n  this.params = params;\n  this.nodeStates = {};\n  this.frameID = null;\n  this.running = false;\n  this.killed = false;\n\n  // TODO: hook listeners on graph to listen to dropNode, dropEdge, clear, clearEdges\n}\n\nForceSupervisor.prototype.isRunning = function () {\n  return this.running;\n};\n\nForceSupervisor.prototype.runFrame = function () {\n  let {converged} = iterate(this.graph, this.nodeStates, this.params);\n\n  helpers.assignLayoutChanges(this.graph, this.nodeStates, this.params);\n\n  // TODO: figure out convergence\n  converged = false;\n\n  if (converged) {\n    if (this.callbacks.onConverged) this.callbacks.onConverged();\n    this.stop();\n  } else {\n    this.frameID = window.requestAnimationFrame(() => this.runFrame());\n  }\n};\n\nForceSupervisor.prototype.stop = function () {\n  this.running = false;\n\n  if (this.frameID !== null) {\n    window.cancelAnimationFrame(this.frameID);\n    this.frameID = null;\n  }\n\n  return this;\n};\n\nForceSupervisor.prototype.start = function () {\n  if (this.killed)\n    throw new Error('graphology-layout-force/worker.start: layout was killed.');\n\n  if (this.running) return;\n\n  this.running = true;\n  this.runFrame();\n};\n\nForceSupervisor.prototype.kill = function () {\n  this.stop();\n  delete this.nodeStates;\n  this.killed = true;\n\n  // TODO: cleanup events\n};\n\nmodule.exports = ForceSupervisor;\n", "import { useLayoutFactory } from '@react-sigma/layout-core';\nimport force, { ForceLayoutParameters } from 'graphology-layout-force';\n\n/**\n * React hook that helps you to manage [force layout](https://graphology.github.io/standard-library/layout-force.html).\n *\n * ```typescript\n * const { positions, assign } = useLayoutForce(...);\n *```\n * @category Hook\n */\nexport function useLayoutForce(\n  options: ForceLayoutParameters = {\n    maxIterations: 100,\n  },\n) {\n  return useLayoutFactory<ForceLayoutParameters>(force, options);\n}\n", "import { useWorkerLayoutFactory } from '@react-sigma/layout-core';\nimport ForceSupervisor, { ForceLayoutSupervisorParameters } from 'graphology-layout-force/worker';\n\n/**\n * React hook that helps you to manage worker of [force layout](https://graphology.github.io/standard-library/layout-force.html).\n *\n * ```typescript\n * const { stop, start } = useWorkerLayoutForce(...);\n *```\n * @category Hook\n */\nexport function useWorkerLayoutForce(options: ForceLayoutSupervisorParameters = {}) {\n  return useWorkerLayoutFactory<ForceLayoutSupervisorParameters>(ForceSupervisor, options);\n}\n", "import { WorkerLayoutControl, WorkerLayoutControlProps } from '@react-sigma/layout-core';\nimport { ForceLayoutSupervisorParameters } from 'graphology-layout-force/worker';\nimport React from 'react';\n\nimport { useWorkerLayoutForce } from './useWorkerLayoutForce';\n\n/**\n * Properties for `ForceDirectedControl` component\n */\nexport type LayoutForceControlProps = Omit<WorkerLayoutControlProps, 'layout' | 'settings'> & {\n  settings?: ForceLayoutSupervisorParameters;\n};\n\n/**\n * Component that display a button to start/stop the layout.\n *\n * @category Component\n */\nexport const LayoutForceControl: React.FC<LayoutForceControlProps> = ({\n  id,\n  className,\n  style,\n  settings = {},\n  autoRunFor,\n  children,\n  labels,\n}) => {\n  const layout = useWorkerLayoutForce(settings);\n  const workerLayoutProps = { id, className, style, autoRunFor, labels, layout };\n  return <WorkerLayoutControl {...workerLayoutProps}>{children}</WorkerLayoutControl>;\n};\n"],
  "mappings": "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",
  "names": ["n", "n", "require_defaults", "useLayoutForce", "options", "maxIterations", "useLayoutFactory", "force", "useWorkerLayoutForce", "useWorkerLayoutFactory", "ForceSupervisor", "LayoutForceControl", "id", "className", "style", "settings", "autoRunFor", "children", "labels", "workerLayoutProps", "layout", "React", "WorkerLayoutControl", "Object", "assign"]
}
