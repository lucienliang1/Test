import {
  require_defaults
} from "./chunk-A3ISJEXD.js";
import {
  o
} from "./chunk-QBFRYOH7.js";
import "./chunk-4VMHPG2O.js";
import {
  require_is_graph
} from "./chunk-KWB6VWZC.js";
import "./chunk-5R2YFWNI.js";
import "./chunk-FCKPN5ZG.js";
import "./chunk-KNJF7WWH.js";
import "./chunk-IYWZER4T.js";
import {
  __commonJS,
  __toESM
} from "./chunk-FDBJFBLO.js";

// node_modules/pandemonium/random.js
var require_random = __commonJS({
  "node_modules/pandemonium/random.js"(exports, module) {
    function createRandom(rng) {
      return function(a, b) {
        return a + Math.floor(rng() * (b - a + 1));
      };
    }
    var random = createRandom(Math.random);
    random.createRandom = createRandom;
    module.exports = random;
  }
});

// node_modules/pandemonium/shuffle-in-place.js
var require_shuffle_in_place = __commonJS({
  "node_modules/pandemonium/shuffle-in-place.js"(exports, module) {
    var createRandom = require_random().createRandom;
    function createShuffleInPlace(rng) {
      var customRandom = createRandom(rng);
      return function(sequence) {
        var length = sequence.length, lastIndex = length - 1;
        var index = -1;
        while (++index < length) {
          var r2 = customRandom(index, lastIndex), value = sequence[r2];
          sequence[r2] = sequence[index];
          sequence[index] = value;
        }
      };
    }
    var shuffleInPlace = createShuffleInPlace(Math.random);
    shuffleInPlace.createShuffleInPlace = createShuffleInPlace;
    module.exports = shuffleInPlace;
  }
});

// node_modules/graphology-layout/circlepack.js
var require_circlepack = __commonJS({
  "node_modules/graphology-layout/circlepack.js"(exports, module) {
    var resolveDefaults = require_defaults();
    var isGraph = require_is_graph();
    var shuffle = require_shuffle_in_place();
    var DEFAULTS = {
      attributes: {
        x: "x",
        y: "y"
      },
      center: 0,
      hierarchyAttributes: [],
      rng: Math.random,
      scale: 1
    };
    function CircleWrap(id, x, y, r2, circleWrap) {
      this.wrappedCircle = circleWrap || null;
      this.children = {};
      this.countChildren = 0;
      this.id = id || null;
      this.next = null;
      this.previous = null;
      this.x = x || null;
      this.y = y || null;
      if (circleWrap) this.r = 1010101;
      else this.r = r2 || 999;
    }
    CircleWrap.prototype.hasChildren = function() {
      return this.countChildren > 0;
    };
    CircleWrap.prototype.addChild = function(id, child) {
      this.children[id] = child;
      ++this.countChildren;
    };
    CircleWrap.prototype.getChild = function(id) {
      if (!this.children.hasOwnProperty(id)) {
        var circleWrap = new CircleWrap();
        this.children[id] = circleWrap;
        ++this.countChildren;
      }
      return this.children[id];
    };
    CircleWrap.prototype.applyPositionToChildren = function() {
      if (this.hasChildren()) {
        var root = this;
        for (var key in root.children) {
          var child = root.children[key];
          child.x += root.x;
          child.y += root.y;
          child.applyPositionToChildren();
        }
      }
    };
    function setNode(graph, parentCircle, posMap) {
      for (var key in parentCircle.children) {
        var circle = parentCircle.children[key];
        if (circle.hasChildren()) {
          setNode(graph, circle, posMap);
        } else {
          posMap[circle.id] = { x: circle.x, y: circle.y };
        }
      }
    }
    function enclosesNot(a, b) {
      var dr = a.r - b.r;
      var dx = b.x - a.x;
      var dy = b.y - a.y;
      return dr < 0 || dr * dr < dx * dx + dy * dy;
    }
    function enclosesWeak(a, b) {
      var dr = a.r - b.r + 1e-6;
      var dx = b.x - a.x;
      var dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }
    function enclosesWeakAll(a, B) {
      for (var i = 0; i < B.length; ++i) {
        if (!enclosesWeak(a, B[i])) {
          return false;
        }
      }
      return true;
    }
    function encloseBasis1(a) {
      return new CircleWrap(null, a.x, a.y, a.r);
    }
    function encloseBasis2(a, b) {
      var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
      return new CircleWrap(
        null,
        (x1 + x2 + x21 / l * r21) / 2,
        (y1 + y2 + y21 / l * r21) / 2,
        (l + r1 + r2) / 2
      );
    }
    function encloseBasis3(a, b, c) {
      var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c.x, y3 = c.y, r3 = c.r, a2 = x1 - x2, a3 = x1 - x3, b2 = y1 - y2, b3 = y1 - y3, c2 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b2 - a2 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1, xb = (b3 * c2 - b2 * c3) / ab, ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1, yb = (a2 * c3 - a3 * c2) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r4 = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
      return new CircleWrap(null, x1 + xa + xb * r4, y1 + ya + yb * r4, r4);
    }
    function encloseBasis(B) {
      switch (B.length) {
        case 1:
          return encloseBasis1(B[0]);
        case 2:
          return encloseBasis2(B[0], B[1]);
        case 3:
          return encloseBasis3(B[0], B[1], B[2]);
        default:
          throw new Error(
            "graphology-layout/circlepack: Invalid basis length " + B.length
          );
      }
    }
    function extendBasis(B, p) {
      var i, j;
      if (enclosesWeakAll(p, B)) return [p];
      for (i = 0; i < B.length; ++i) {
        if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
          return [B[i], p];
        }
      }
      for (i = 0; i < B.length - 1; ++i) {
        for (j = i + 1; j < B.length; ++j) {
          if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
            return [B[i], B[j], p];
          }
        }
      }
      throw new Error("graphology-layout/circlepack: extendBasis failure !");
    }
    function score(node) {
      var a = node.wrappedCircle;
      var b = node.next.wrappedCircle;
      var ab = a.r + b.r;
      var dx = (a.x * b.r + b.x * a.r) / ab;
      var dy = (a.y * b.r + b.y * a.r) / ab;
      return dx * dx + dy * dy;
    }
    function enclose(circles, shuffleFunc) {
      var i = 0;
      var circlesLoc = circles.slice();
      var n = circles.length;
      var B = [];
      var p;
      var e;
      shuffleFunc(circlesLoc);
      while (i < n) {
        p = circlesLoc[i];
        if (e && enclosesWeak(e, p)) {
          ++i;
        } else {
          B = extendBasis(B, p);
          e = encloseBasis(B);
          i = 0;
        }
      }
      return e;
    }
    function place(b, a, c) {
      var dx = b.x - a.x, x, a2, dy = b.y - a.y, y, b2, d2 = dx * dx + dy * dy;
      if (d2) {
        a2 = a.r + c.r;
        a2 *= a2;
        b2 = b.r + c.r;
        b2 *= b2;
        if (a2 > b2) {
          x = (d2 + b2 - a2) / (2 * d2);
          y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
          c.x = b.x - x * dx - y * dy;
          c.y = b.y - x * dy + y * dx;
        } else {
          x = (d2 + a2 - b2) / (2 * d2);
          y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
          c.x = a.x + x * dx - y * dy;
          c.y = a.y + x * dy + y * dx;
        }
      } else {
        c.x = a.x + c.r;
        c.y = a.y;
      }
    }
    function intersects(a, b) {
      var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }
    function packEnclose(circles, shuffleFunc) {
      var n = circles.length;
      if (n === 0) return 0;
      var a, b, c, aa, ca, i, j, k, sj, sk;
      a = circles[0];
      a.x = 0;
      a.y = 0;
      if (n <= 1) return a.r;
      b = circles[1];
      a.x = -b.r;
      b.x = a.r;
      b.y = 0;
      if (n <= 2) return a.r + b.r;
      c = circles[2];
      place(b, a, c);
      a = new CircleWrap(null, null, null, null, a);
      b = new CircleWrap(null, null, null, null, b);
      c = new CircleWrap(null, null, null, null, c);
      a.next = c.previous = b;
      b.next = a.previous = c;
      c.next = b.previous = a;
      pack: for (i = 3; i < n; ++i) {
        c = circles[i];
        place(a.wrappedCircle, b.wrappedCircle, c);
        c = new CircleWrap(null, null, null, null, c);
        j = b.next;
        k = a.previous;
        sj = b.wrappedCircle.r;
        sk = a.wrappedCircle.r;
        do {
          if (sj <= sk) {
            if (intersects(j.wrappedCircle, c.wrappedCircle)) {
              b = j;
              a.next = b;
              b.previous = a;
              --i;
              continue pack;
            }
            sj += j.wrappedCircle.r;
            j = j.next;
          } else {
            if (intersects(k.wrappedCircle, c.wrappedCircle)) {
              a = k;
              a.next = b;
              b.previous = a;
              --i;
              continue pack;
            }
            sk += k.wrappedCircle.r;
            k = k.previous;
          }
        } while (j !== k.next);
        c.previous = a;
        c.next = b;
        a.next = b.previous = b = c;
        aa = score(a);
        while ((c = c.next) !== b) {
          if ((ca = score(c)) < aa) {
            a = c;
            aa = ca;
          }
        }
        b = a.next;
      }
      a = [b.wrappedCircle];
      c = b;
      var safety = 1e4;
      while ((c = c.next) !== b) {
        if (--safety === 0) {
          break;
        }
        a.push(c.wrappedCircle);
      }
      c = enclose(a, shuffleFunc);
      for (i = 0; i < n; ++i) {
        a = circles[i];
        a.x -= c.x;
        a.y -= c.y;
      }
      return c.r;
    }
    function packHierarchy(parentCircle, shuffleFunc) {
      var r2 = 0;
      if (parentCircle.hasChildren()) {
        for (var key in parentCircle.children) {
          var circle = parentCircle.children[key];
          if (circle.hasChildren()) {
            circle.r = packHierarchy(circle, shuffleFunc);
          }
        }
        r2 = packEnclose(Object.values(parentCircle.children), shuffleFunc);
      }
      return r2;
    }
    function packHierarchyAndShift(parentCircle, shuffleFunc) {
      packHierarchy(parentCircle, shuffleFunc);
      for (var key in parentCircle.children) {
        var circle = parentCircle.children[key];
        circle.applyPositionToChildren();
      }
    }
    function genericCirclePackLayout(assign, graph, options) {
      if (!isGraph(graph))
        throw new Error(
          "graphology-layout/circlepack: the given graph is not a valid graphology instance."
        );
      options = resolveDefaults(options, DEFAULTS);
      var posMap = {}, positions = {}, nodes = graph.nodes(), center = options.center, hierarchyAttributes = options.hierarchyAttributes, shuffleFunc = shuffle.createShuffleInPlace(options.rng), scale = options.scale;
      var container = new CircleWrap();
      graph.forEachNode(function(key, attributes) {
        var r2 = attributes.size ? attributes.size : 1;
        var newCircleWrap = new CircleWrap(key, null, null, r2);
        var parentContainer = container;
        hierarchyAttributes.forEach(function(v) {
          var attr = attributes[v];
          parentContainer = parentContainer.getChild(attr);
        });
        parentContainer.addChild(key, newCircleWrap);
      });
      packHierarchyAndShift(container, shuffleFunc);
      setNode(graph, container, posMap);
      var l = nodes.length, x, y, i;
      for (i = 0; i < l; i++) {
        var node = nodes[i];
        x = center + scale * posMap[node].x;
        y = center + scale * posMap[node].y;
        positions[node] = {
          x,
          y
        };
        if (assign) {
          graph.setNodeAttribute(node, options.attributes.x, x);
          graph.setNodeAttribute(node, options.attributes.y, y);
        }
      }
      return positions;
    }
    var circlePackLayout = genericCirclePackLayout.bind(null, false);
    circlePackLayout.assign = genericCirclePackLayout.bind(null, true);
    module.exports = circlePackLayout;
  }
});

// node_modules/@react-sigma/layout-circlepack/lib/react-sigma_layout-circlepack.esm.min.js
var import_circlepack = __toESM(require_circlepack());
function t(t2 = {}) {
  return o(import_circlepack.default, t2);
}
export {
  t as useLayoutCirclepack
};
//# sourceMappingURL=@react-sigma_layout-circlepack.js.map
