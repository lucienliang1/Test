{
  "version": 3,
  "sources": ["../../graphology-layout-noverlap/iterate.js", "../../graphology-layout-noverlap/helpers.js", "../../graphology-layout-noverlap/defaults.js", "../../graphology-layout-noverlap/index.js", "../../graphology-layout-noverlap/webworker.js", "../../graphology-layout-noverlap/worker.js", "../../@react-sigma/layout-noverlap/src/useLayoutNoverlap.ts", "../../@react-sigma/layout-noverlap/src/useWorkerLayoutNoverlap.ts", "../../@react-sigma/layout-noverlap/src/LayoutNoverlapControl.tsx"],
  "sourcesContent": ["/**\n * Graphology Noverlap Iteration\n * ==============================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0,\n  NODE_Y = 1,\n  NODE_SIZE = 2;\n\n/**\n * Constants.\n */\nvar PPN = 3;\n\n/**\n * Helpers.\n */\nfunction hashPair(a, b) {\n  return a + 'ยง' + b;\n}\n\nfunction jitter() {\n  return 0.01 * (0.5 - Math.random());\n}\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @return {object}                  - Some metadata.\n */\nmodule.exports = function iterate(options, NodeMatrix) {\n  // Caching options\n  var margin = options.margin;\n  var ratio = options.ratio;\n  var expansion = options.expansion;\n  var gridSize = options.gridSize; // TODO: decrease grid size when few nodes?\n  var speed = options.speed;\n\n  // Generic iteration variables\n  var i, j, x, y, l, size;\n  var converged = true;\n\n  var length = NodeMatrix.length;\n  var order = (length / PPN) | 0;\n\n  var deltaX = new Float32Array(order);\n  var deltaY = new Float32Array(order);\n\n  // Finding the extents of our space\n  var xMin = Infinity;\n  var yMin = Infinity;\n  var xMax = -Infinity;\n  var yMax = -Infinity;\n\n  for (i = 0; i < length; i += PPN) {\n    x = NodeMatrix[i + NODE_X];\n    y = NodeMatrix[i + NODE_Y];\n    size = NodeMatrix[i + NODE_SIZE] * ratio + margin;\n\n    xMin = Math.min(xMin, x - size);\n    xMax = Math.max(xMax, x + size);\n    yMin = Math.min(yMin, y - size);\n    yMax = Math.max(yMax, y + size);\n  }\n\n  var width = xMax - xMin;\n  var height = yMax - yMin;\n  var xCenter = (xMin + xMax) / 2;\n  var yCenter = (yMin + yMax) / 2;\n\n  xMin = xCenter - (expansion * width) / 2;\n  xMax = xCenter + (expansion * width) / 2;\n  yMin = yCenter - (expansion * height) / 2;\n  yMax = yCenter + (expansion * height) / 2;\n\n  // Building grid\n  var grid = new Array(gridSize * gridSize),\n    gridLength = grid.length,\n    c;\n\n  for (c = 0; c < gridLength; c++) grid[c] = [];\n\n  var nxMin, nxMax, nyMin, nyMax;\n  var xMinBox, xMaxBox, yMinBox, yMaxBox;\n\n  var col, row;\n\n  for (i = 0; i < length; i += PPN) {\n    x = NodeMatrix[i + NODE_X];\n    y = NodeMatrix[i + NODE_Y];\n    size = NodeMatrix[i + NODE_SIZE] * ratio + margin;\n\n    nxMin = x - size;\n    nxMax = x + size;\n    nyMin = y - size;\n    nyMax = y + size;\n\n    xMinBox = Math.floor((gridSize * (nxMin - xMin)) / (xMax - xMin));\n    xMaxBox = Math.floor((gridSize * (nxMax - xMin)) / (xMax - xMin));\n    yMinBox = Math.floor((gridSize * (nyMin - yMin)) / (yMax - yMin));\n    yMaxBox = Math.floor((gridSize * (nyMax - yMin)) / (yMax - yMin));\n\n    for (col = xMinBox; col <= xMaxBox; col++) {\n      for (row = yMinBox; row <= yMaxBox; row++) {\n        grid[col * gridSize + row].push(i);\n      }\n    }\n  }\n\n  // Computing collisions\n  var cell;\n\n  var collisions = new Set();\n\n  var n1, n2, x1, x2, y1, y2, s1, s2, h;\n\n  var xDist, yDist, dist, collision;\n\n  for (c = 0; c < gridLength; c++) {\n    cell = grid[c];\n\n    for (i = 0, l = cell.length; i < l; i++) {\n      n1 = cell[i];\n\n      x1 = NodeMatrix[n1 + NODE_X];\n      y1 = NodeMatrix[n1 + NODE_Y];\n      s1 = NodeMatrix[n1 + NODE_SIZE];\n\n      for (j = i + 1; j < l; j++) {\n        n2 = cell[j];\n        h = hashPair(n1, n2);\n\n        if (gridLength > 1 && collisions.has(h)) continue;\n\n        if (gridLength > 1) collisions.add(h);\n\n        x2 = NodeMatrix[n2 + NODE_X];\n        y2 = NodeMatrix[n2 + NODE_Y];\n        s2 = NodeMatrix[n2 + NODE_SIZE];\n\n        xDist = x2 - x1;\n        yDist = y2 - y1;\n        dist = Math.sqrt(xDist * xDist + yDist * yDist);\n        collision = dist < s1 * ratio + margin + (s2 * ratio + margin);\n\n        if (collision) {\n          converged = false;\n\n          n2 = (n2 / PPN) | 0;\n\n          if (dist > 0) {\n            deltaX[n2] += (xDist / dist) * (1 + s1);\n            deltaY[n2] += (yDist / dist) * (1 + s1);\n          } else {\n            // Nodes are on the exact same spot, we need to jitter a bit\n            deltaX[n2] += width * jitter();\n            deltaY[n2] += height * jitter();\n          }\n        }\n      }\n    }\n  }\n\n  for (i = 0, j = 0; i < length; i += PPN, j++) {\n    NodeMatrix[i + NODE_X] += deltaX[j] * 0.1 * speed;\n    NodeMatrix[i + NODE_Y] += deltaY[j] * 0.1 * speed;\n  }\n\n  return {converged: converged};\n};\n", "/**\n * Graphology Noverlap Helpers\n * ============================\n *\n * Miscellaneous helper functions.\n */\n\n/**\n * Constants.\n */\nvar PPN = 3;\n\n/**\n * Function used to validate the given settings.\n *\n * @param  {object}      settings - Settings to validate.\n * @return {object|null}\n */\nexports.validateSettings = function (settings) {\n  if (\n    ('gridSize' in settings && typeof settings.gridSize !== 'number') ||\n    settings.gridSize <= 0\n  )\n    return {message: 'the `gridSize` setting should be a positive number.'};\n\n  if (\n    ('margin' in settings && typeof settings.margin !== 'number') ||\n    settings.margin < 0\n  )\n    return {\n      message: 'the `margin` setting should be 0 or a positive number.'\n    };\n\n  if (\n    ('expansion' in settings && typeof settings.expansion !== 'number') ||\n    settings.expansion <= 0\n  )\n    return {message: 'the `expansion` setting should be a positive number.'};\n\n  if (\n    ('ratio' in settings && typeof settings.ratio !== 'number') ||\n    settings.ratio <= 0\n  )\n    return {message: 'the `ratio` setting should be a positive number.'};\n\n  if (\n    ('speed' in settings && typeof settings.speed !== 'number') ||\n    settings.speed <= 0\n  )\n    return {message: 'the `speed` setting should be a positive number.'};\n\n  return null;\n};\n\n/**\n * Function generating a flat matrix for the given graph's nodes.\n *\n * @param  {Graph}        graph   - Target graph.\n * @param  {function}     reducer - Node reducer function.\n * @return {Float32Array}         - The node matrix.\n */\nexports.graphToByteArray = function (graph, reducer) {\n  var order = graph.order;\n\n  var matrix = new Float32Array(order * PPN);\n\n  var j = 0;\n\n  graph.forEachNode(function (node, attr) {\n    if (typeof reducer === 'function') attr = reducer(node, attr);\n\n    matrix[j] = attr.x;\n    matrix[j + 1] = attr.y;\n    matrix[j + 2] = attr.size || 1;\n    j += PPN;\n  });\n\n  return matrix;\n};\n\n/**\n * Function applying the layout back to the graph.\n *\n * @param {Graph}        graph      - Target graph.\n * @param {Float32Array} NodeMatrix - Node matrix.\n * @param {function}     reducer    - Reducing function.\n */\nexports.assignLayoutChanges = function (graph, NodeMatrix, reducer) {\n  var i = 0;\n\n  graph.forEachNode(function (node) {\n    var pos = {\n      x: NodeMatrix[i],\n      y: NodeMatrix[i + 1]\n    };\n\n    if (typeof reducer === 'function') pos = reducer(node, pos);\n\n    graph.mergeNodeAttributes(node, pos);\n\n    i += PPN;\n  });\n};\n\n/**\n * Function collecting the layout positions.\n *\n * @param  {Graph}        graph      - Target graph.\n * @param  {Float32Array} NodeMatrix - Node matrix.\n * @param  {function}     reducer    - Reducing function.\n * @return {object}                  - Map to node positions.\n */\nexports.collectLayoutChanges = function (graph, NodeMatrix, reducer) {\n  var positions = {};\n\n  var i = 0;\n\n  graph.forEachNode(function (node) {\n    var pos = {\n      x: NodeMatrix[i],\n      y: NodeMatrix[i + 1]\n    };\n\n    if (typeof reducer === 'function') pos = reducer(node, pos);\n\n    positions[node] = pos;\n\n    i += PPN;\n  });\n\n  return positions;\n};\n\n/**\n * Function returning a web worker from the given function.\n *\n * @param  {function}  fn - Function for the worker.\n * @return {DOMString}\n */\nexports.createWorker = function createWorker(fn) {\n  var xURL = window.URL || window.webkitURL;\n  var code = fn.toString();\n  var objectUrl = xURL.createObjectURL(\n    new Blob(['(' + code + ').call(this);'], {type: 'text/javascript'})\n  );\n  var worker = new Worker(objectUrl);\n  xURL.revokeObjectURL(objectUrl);\n\n  return worker;\n};\n", "/**\n * Graphology Noverlap Layout Default Settings\n * ============================================\n */\nmodule.exports = {\n  gridSize: 20,\n  margin: 5,\n  expansion: 1.1,\n  ratio: 1.0,\n  speed: 3\n};\n", "/**\n * Graphology Noverlap Layout\n * ===========================\n *\n * Library endpoint.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar iterate = require('./iterate.js');\nvar helpers = require('./helpers.js');\n\nvar DEFAULT_SETTINGS = require('./defaults.js');\nvar DEFAULT_MAX_ITERATIONS = 500;\n\n/**\n * Asbtract function used to run a certain number of iterations.\n *\n * @param  {boolean}       assign       - Whether to assign positions.\n * @param  {Graph}         graph        - Target graph.\n * @param  {object|number} params       - If number, params.maxIterations, else:\n * @param  {number}          maxIterations - Maximum number of iterations.\n * @param  {object}          [settings] - Settings.\n * @return {object|undefined}\n */\nfunction abstractSynchronousLayout(assign, graph, params) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout-noverlap: the given graph is not a valid graphology instance.'\n    );\n\n  if (typeof params === 'number') params = {maxIterations: params};\n  else params = params || {};\n\n  var maxIterations = params.maxIterations || DEFAULT_MAX_ITERATIONS;\n\n  if (typeof maxIterations !== 'number' || maxIterations <= 0)\n    throw new Error(\n      'graphology-layout-force: you should provide a positive number of maximum iterations.'\n    );\n\n  // Validating settings\n  var settings = Object.assign({}, DEFAULT_SETTINGS, params.settings),\n    validationError = helpers.validateSettings(settings);\n\n  if (validationError)\n    throw new Error('graphology-layout-noverlap: ' + validationError.message);\n\n  // Building matrices\n  var matrix = helpers.graphToByteArray(graph, params.inputReducer),\n    converged = false,\n    i;\n\n  // Iterating\n  for (i = 0; i < maxIterations && !converged; i++)\n    converged = iterate(settings, matrix).converged;\n\n  // Applying\n  if (assign) {\n    helpers.assignLayoutChanges(graph, matrix, params.outputReducer);\n    return;\n  }\n\n  return helpers.collectLayoutChanges(graph, matrix, params.outputReducer);\n}\n\n/**\n * Exporting.\n */\nvar synchronousLayout = abstractSynchronousLayout.bind(null, false);\nsynchronousLayout.assign = abstractSynchronousLayout.bind(null, true);\n\nmodule.exports = synchronousLayout;\n", "/**\n * Graphology Noverlap Layout Webworker\n * =====================================\n *\n * Web worker able to run the layout in a separate thread.\n */\nmodule.exports = function worker() {\n  var NODES;\n\n  var moduleShim = {};\n\n  (function () {\n    /**\n * Graphology Noverlap Iteration\n * ==============================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0,\n  NODE_Y = 1,\n  NODE_SIZE = 2;\n\n/**\n * Constants.\n */\nvar PPN = 3;\n\n/**\n * Helpers.\n */\nfunction hashPair(a, b) {\n  return a + 'ยง' + b;\n}\n\nfunction jitter() {\n  return 0.01 * (0.5 - Math.random());\n}\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @return {object}                  - Some metadata.\n */\nmoduleShim.exports = function iterate(options, NodeMatrix) {\n  // Caching options\n  var margin = options.margin;\n  var ratio = options.ratio;\n  var expansion = options.expansion;\n  var gridSize = options.gridSize; // TODO: decrease grid size when few nodes?\n  var speed = options.speed;\n\n  // Generic iteration variables\n  var i, j, x, y, l, size;\n  var converged = true;\n\n  var length = NodeMatrix.length;\n  var order = (length / PPN) | 0;\n\n  var deltaX = new Float32Array(order);\n  var deltaY = new Float32Array(order);\n\n  // Finding the extents of our space\n  var xMin = Infinity;\n  var yMin = Infinity;\n  var xMax = -Infinity;\n  var yMax = -Infinity;\n\n  for (i = 0; i < length; i += PPN) {\n    x = NodeMatrix[i + NODE_X];\n    y = NodeMatrix[i + NODE_Y];\n    size = NodeMatrix[i + NODE_SIZE] * ratio + margin;\n\n    xMin = Math.min(xMin, x - size);\n    xMax = Math.max(xMax, x + size);\n    yMin = Math.min(yMin, y - size);\n    yMax = Math.max(yMax, y + size);\n  }\n\n  var width = xMax - xMin;\n  var height = yMax - yMin;\n  var xCenter = (xMin + xMax) / 2;\n  var yCenter = (yMin + yMax) / 2;\n\n  xMin = xCenter - (expansion * width) / 2;\n  xMax = xCenter + (expansion * width) / 2;\n  yMin = yCenter - (expansion * height) / 2;\n  yMax = yCenter + (expansion * height) / 2;\n\n  // Building grid\n  var grid = new Array(gridSize * gridSize),\n    gridLength = grid.length,\n    c;\n\n  for (c = 0; c < gridLength; c++) grid[c] = [];\n\n  var nxMin, nxMax, nyMin, nyMax;\n  var xMinBox, xMaxBox, yMinBox, yMaxBox;\n\n  var col, row;\n\n  for (i = 0; i < length; i += PPN) {\n    x = NodeMatrix[i + NODE_X];\n    y = NodeMatrix[i + NODE_Y];\n    size = NodeMatrix[i + NODE_SIZE] * ratio + margin;\n\n    nxMin = x - size;\n    nxMax = x + size;\n    nyMin = y - size;\n    nyMax = y + size;\n\n    xMinBox = Math.floor((gridSize * (nxMin - xMin)) / (xMax - xMin));\n    xMaxBox = Math.floor((gridSize * (nxMax - xMin)) / (xMax - xMin));\n    yMinBox = Math.floor((gridSize * (nyMin - yMin)) / (yMax - yMin));\n    yMaxBox = Math.floor((gridSize * (nyMax - yMin)) / (yMax - yMin));\n\n    for (col = xMinBox; col <= xMaxBox; col++) {\n      for (row = yMinBox; row <= yMaxBox; row++) {\n        grid[col * gridSize + row].push(i);\n      }\n    }\n  }\n\n  // Computing collisions\n  var cell;\n\n  var collisions = new Set();\n\n  var n1, n2, x1, x2, y1, y2, s1, s2, h;\n\n  var xDist, yDist, dist, collision;\n\n  for (c = 0; c < gridLength; c++) {\n    cell = grid[c];\n\n    for (i = 0, l = cell.length; i < l; i++) {\n      n1 = cell[i];\n\n      x1 = NodeMatrix[n1 + NODE_X];\n      y1 = NodeMatrix[n1 + NODE_Y];\n      s1 = NodeMatrix[n1 + NODE_SIZE];\n\n      for (j = i + 1; j < l; j++) {\n        n2 = cell[j];\n        h = hashPair(n1, n2);\n\n        if (gridLength > 1 && collisions.has(h)) continue;\n\n        if (gridLength > 1) collisions.add(h);\n\n        x2 = NodeMatrix[n2 + NODE_X];\n        y2 = NodeMatrix[n2 + NODE_Y];\n        s2 = NodeMatrix[n2 + NODE_SIZE];\n\n        xDist = x2 - x1;\n        yDist = y2 - y1;\n        dist = Math.sqrt(xDist * xDist + yDist * yDist);\n        collision = dist < s1 * ratio + margin + (s2 * ratio + margin);\n\n        if (collision) {\n          converged = false;\n\n          n2 = (n2 / PPN) | 0;\n\n          if (dist > 0) {\n            deltaX[n2] += (xDist / dist) * (1 + s1);\n            deltaY[n2] += (yDist / dist) * (1 + s1);\n          } else {\n            // Nodes are on the exact same spot, we need to jitter a bit\n            deltaX[n2] += width * jitter();\n            deltaY[n2] += height * jitter();\n          }\n        }\n      }\n    }\n  }\n\n  for (i = 0, j = 0; i < length; i += PPN, j++) {\n    NodeMatrix[i + NODE_X] += deltaX[j] * 0.1 * speed;\n    NodeMatrix[i + NODE_Y] += deltaY[j] * 0.1 * speed;\n  }\n\n  return {converged: converged};\n};\n\n  })();\n\n  var iterate = moduleShim.exports;\n\n  self.addEventListener('message', function (event) {\n    var data = event.data;\n\n    NODES = new Float32Array(data.nodes);\n\n    // Running the iteration\n    var result = iterate(data.settings, NODES);\n\n    // Sending result to supervisor\n    self.postMessage(\n      {\n        result: result,\n        nodes: NODES.buffer\n      },\n      [NODES.buffer]\n    );\n  });\n};\n\n", "/**\n * Graphology Noverlap Layout Supervisor\n * ======================================\n *\n * Supervisor class able to spawn a web worker to run the Noverlap layout in a\n * separate thread not to block UI with heavy synchronous computations.\n */\nvar workerFunction = require('./webworker.js'),\n  isGraph = require('graphology-utils/is-graph'),\n  helpers = require('./helpers.js');\n\nvar DEFAULT_SETTINGS = require('./defaults.js');\n\n/**\n * Class representing a Noverlap layout run by a webworker.\n *\n * @constructor\n * @param  {Graph}         graph        - Target graph.\n * @param  {object|number} params       - Parameters:\n * @param  {object}          [settings] - Settings.\n */\nfunction NoverlapLayoutSupervisor(graph, params) {\n  params = params || {};\n\n  // Validation\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout-noverlap/worker: the given graph is not a valid graphology instance.'\n    );\n\n  // Validating settings\n  var settings = Object.assign({}, DEFAULT_SETTINGS, params.settings),\n    validationError = helpers.validateSettings(settings);\n\n  if (validationError)\n    throw new Error(\n      'graphology-layout-noverlap/worker: ' + validationError.message\n    );\n\n  // Properties\n  this.worker = null;\n  this.graph = graph;\n  this.settings = settings;\n  this.matrices = null;\n  this.running = false;\n  this.killed = false;\n\n  this.inputReducer = params.inputReducer;\n  this.outputReducer = params.outputReducer;\n\n  this.callbacks = {\n    onConverged:\n      typeof params.onConverged === 'function' ? params.onConverged : null\n  };\n\n  // Binding listeners\n  this.handleMessage = this.handleMessage.bind(this);\n\n  var alreadyRespawning = false;\n  var self = this;\n\n  this.handleAddition = function () {\n    if (alreadyRespawning) return;\n\n    alreadyRespawning = true;\n\n    self.spawnWorker();\n    setTimeout(function () {\n      alreadyRespawning = false;\n    }, 0);\n  };\n\n  graph.on('nodeAdded', this.handleAddition);\n  graph.on('edgeAdded', this.handleAddition);\n\n  // Spawning worker\n  this.spawnWorker();\n}\n\nNoverlapLayoutSupervisor.prototype.isRunning = function () {\n  return this.running;\n};\n\n/**\n * Internal method used to spawn the web worker.\n */\nNoverlapLayoutSupervisor.prototype.spawnWorker = function () {\n  if (this.worker) this.worker.terminate();\n\n  this.worker = helpers.createWorker(workerFunction);\n  this.worker.addEventListener('message', this.handleMessage);\n\n  if (this.running) {\n    this.running = false;\n    this.start();\n  }\n};\n\n/**\n * Internal method used to handle the worker's messages.\n *\n * @param {object} event - Event to handle.\n */\nNoverlapLayoutSupervisor.prototype.handleMessage = function (event) {\n  if (!this.running) return;\n\n  var matrix = new Float32Array(event.data.nodes);\n\n  helpers.assignLayoutChanges(this.graph, matrix, this.outputReducer);\n  this.matrices.nodes = matrix;\n\n  if (event.data.result.converged) {\n    if (this.callbacks.onConverged) this.callbacks.onConverged();\n\n    this.stop();\n    return;\n  }\n\n  // Looping\n  this.askForIterations();\n};\n\n/**\n * Internal method used to ask for iterations from the worker.\n *\n * @return {NoverlapLayoutSupervisor}\n */\nNoverlapLayoutSupervisor.prototype.askForIterations = function () {\n  var matrices = this.matrices;\n\n  var payload = {\n    settings: this.settings,\n    nodes: matrices.nodes.buffer\n  };\n\n  var buffers = [matrices.nodes.buffer];\n\n  this.worker.postMessage(payload, buffers);\n\n  return this;\n};\n\n/**\n * Method used to start the layout.\n *\n * @return {NoverlapLayoutSupervisor}\n */\nNoverlapLayoutSupervisor.prototype.start = function () {\n  if (this.killed)\n    throw new Error(\n      'graphology-layout-noverlap/worker.start: layout was killed.'\n    );\n\n  if (this.running) return this;\n\n  // Building matrices\n  this.matrices = {\n    nodes: helpers.graphToByteArray(this.graph, this.inputReducer)\n  };\n\n  this.running = true;\n  this.askForIterations();\n\n  return this;\n};\n\n/**\n * Method used to stop the layout.\n *\n * @return {NoverlapLayoutSupervisor}\n */\nNoverlapLayoutSupervisor.prototype.stop = function () {\n  this.running = false;\n\n  return this;\n};\n\n/**\n * Method used to kill the layout.\n *\n * @return {NoverlapLayoutSupervisor}\n */\nNoverlapLayoutSupervisor.prototype.kill = function () {\n  if (this.killed) return this;\n\n  this.running = false;\n  this.killed = true;\n\n  // Clearing memory\n  this.matrices = null;\n\n  // Terminating worker\n  this.worker.terminate();\n\n  // Unbinding listeners\n  this.graph.removeListener('nodeAdded', this.handleAddition);\n  this.graph.removeListener('edgeAdded', this.handleAddition);\n};\n\n/**\n * Exporting.\n */\nmodule.exports = NoverlapLayoutSupervisor;\n", "import { useLayoutFactory } from '@react-sigma/layout-core';\nimport noverlap, { NoverlapLayoutParameters } from 'graphology-layout-noverlap';\n\n/**\n * React hook that helps you to manage [noverlap layout](https://graphology.github.io/standard-library/layout-noverlap.html).\n *\n * ```typescript\n * const { positions, assign } = useLayoutNoverlap(...);\n *```\n * @category Hook\n */\nexport function useLayoutNoverlap(options: NoverlapLayoutParameters = {}) {\n  return useLayoutFactory<NoverlapLayoutParameters>(noverlap, options);\n}\n", "import { useWorkerLayoutFactory } from '@react-sigma/layout-core';\nimport NoverlapLayout, { NoverlapLayoutSupervisorParameters } from 'graphology-layout-noverlap/worker';\n\n/**\n * React hook that helps you to manage worker for [noverlap layout](https://graphology.github.io/standard-library/layout-noverlap.html).\n *\n * ```typescript\n * const { stop, start } = useWorkerLayoutNoverlap({layoutOptions});\n *```\n * @category Hook\n */\nexport function useWorkerLayoutNoverlap(options: NoverlapLayoutSupervisorParameters = {}) {\n  return useWorkerLayoutFactory<NoverlapLayoutSupervisorParameters>(NoverlapLayout, options);\n}\n", "import { WorkerLayoutControl, WorkerLayoutControlProps } from '@react-sigma/layout-core';\nimport { NoverlapLayoutSupervisorParameters } from 'graphology-layout-noverlap/worker';\nimport React from 'react';\n\nimport { useWorkerLayoutNoverlap } from './useWorkerLayoutNoverlap';\n\n/**\n * Properties for `NoverlapControl` component\n */\nexport type LayoutNoverlapControlProps = Omit<WorkerLayoutControlProps, 'layout' | 'settings'> & {\n  settings?: NoverlapLayoutSupervisorParameters;\n};\n\n/**\n * @category Component\n */\nexport const LayoutNoverlapControl: React.FC<LayoutNoverlapControlProps> = ({\n  id,\n  className,\n  style,\n  settings = {},\n  autoRunFor,\n  children,\n  labels,\n}) => {\n  const layout = useWorkerLayoutNoverlap(settings);\n  const workerLayoutProps = { id, className, style, autoRunFor, labels, layout };\n  return <WorkerLayoutControl {...workerLayoutProps}>{children}</WorkerLayoutControl>;\n};\n"],
  "mappings": "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",
  "names": ["a", "l", "c", "h", "a", "iterate", "l", "c", "h", "self", "useLayoutNoverlap", "options", "useLayoutFactory", "noverlap", "useWorkerLayoutNoverlap", "useWorkerLayoutFactory", "NoverlapLayout", "LayoutNoverlapControl", "id", "className", "style", "settings", "autoRunFor", "children", "labels", "workerLayoutProps", "layout", "React", "WorkerLayoutControl", "Object", "assign"]
}
